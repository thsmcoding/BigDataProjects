#
# The Python Imaging Library
# $Id$
#
# drawing interface operations
#
# History:
# 1996-04-13 fl   Created (experimental)
# 1996-08-07 fl   Filled polygons, ellipses.
# 1996-08-13 fl   Added text support
# 1998-06-28 fl   Handle I and F images
# 1998-12-29 fl   Added arc; use arc primitive to draw ellipses
# 1999-01-10 fl   Added shape stuff (experimental)
# 1999-02-06 fl   Added bitmap support
# 1999-02-11 fl   Changed all primitives to take options
# 1999-02-20 fl   Fixed backwards compatibility
# 2000-10-12 fl   Copy on write, when necessary
# 2001-02-18 fl   Use default ink for bitmap/text also in fill mode
# 2002-10-24 fl   Added support for CSS-style color strings
# 2002-12-10 fl   Added experimental support for RGBA-on-RGB drawing
# 2002-12-11 fl   Refactored low-level drawing API (work in progress)
# 2004-08-26 fl   Made Draw() a factory function, added getdraw() support
# 2004-09-04 fl   Added width support to line primitive
# 2004-09-10 fl   Added font mode handling
# 2006-06-19 fl   Added font bearing support (getmask2)
#
# Copyright (c) 1997-2006 by Secret Labs AB
# Copyright (c) 1996-2006 by Fredrik Lundh
#
# See the README file for information on usage and redistribution.
#

import math
import numbers

from . import Image, ImageColor


"""
A simple 2D drawing interface for PIL images.
<p>
Application code should use the <b>Draw</b> factory, instead of
directly.
"""


class ImageDraw:
    def __init__(self, im, mode=None):
        """
        Create a drawing instance.

        :param im: The image to draw in.
        :param mode: Optional mode to use for color values.  For RGB
           images, this argument can be RGB or RGBA (to blend the
           drawing into the image).  For all other modes, this argument
           must be the same as the image mode.  If omitted, the mode
           defaults to the mode of the image.
        """
        im.load()
        if im.readonly:
            im._copy()  # make it writeable
        blend = 0
        if mode is None:
            mode = im.mode
        if mode != im.mode:
            if mode == "RGBA" and im.mode == "RGB":
                blend = 1
            else:
                raise ValueError("mode mismatch")
        if mode == "P":
            self.palette = im.palette
        else:
            self.palette = None
        self.im = im.im
        self.draw = Image.core.draw(self.im, blend)
        self.mode = mode
        if mode in ("I", "F"):
            self.ink = self.draw.draw_ink(1)
        else:
            self.ink = self.draw.draw_ink(-1)
        if mode in ("1", "P", "I", "F"):
            # FIXME: fix Fill2 to properly support matte for I+F images
            self.fontmode = "1"
        else:
            self.fontmode = "L"  # aliasing is okay for other modes
        self.fill = 0
        self.font = None

    def getfont(self):
        """
        Get the current default font.

        :returns: An image font."""
        if not self.font:
            # FIXME: should add a font repository
            from . import ImageFont

            self.font = ImageFont.load_default()
        return self.font

    def _getink(self, ink, fill=None):
        if ink is None and fill is None:
            if self.fill:
                fill = self.ink
            else:
                ink = self.ink
        else:
            if ink is not None:
                if isinstance(ink, str):
                    ink = ImageColor.getcolor(ink, self.mode)
                if self.palette and not isinstance(ink, numbers.Number):
                    ink = self.palette.getcolor(ink)
                ink = self.draw.draw_ink(ink)
            if fill is not None:
                if isinstance(fill, str):
                    fill = ImageColor.getcolor(fill, self.mode)
                if self.palette and not isinstance(fill, numbers.Number):
                    fill = self.palette.getcolor(fill)
                fill = self.draw.draw_ink(fill)
        return ink, fill

    def arc(self, xy, start, end, fill=None, width=0):
        """Draw an arc."""
        ink, fill = self._getink(fill)
        if ink is not None:
            self.draw.draw_arc(xy, start, end, ink, width)

    def bitmap(self, xy, bitmap, fill=None):
        """Draw a bitmap."""
        bitmap.load()
        ink, fill = self._getink(fill)
        if ink is None:
            ink = fill
        if ink is not None:
            self.draw.draw_bitmap(xy, bitmap.im, ink)

    def chord(self, xy, start, end, fill=None, outline=None, width=0):
        """Draw a chord."""
        ink, fill = self._getink(outline, fill)
        if fill is not None:
            self.draw.draw_chord(xy, start, end, fill, 1)
        if ink is not None and ink != fill:
            self.draw.draw_chord(xy, start, end, ink, 0, width)

    def ellipse(self, xy, fill=None, outline=None, width=0):
        """Draw an ellipse."""
        ink, fill = self._getink(outline, fill)
        if fill is not None:
            self.draw.draw_ellipse(xy, fill, 1)
        if ink is not None and ink != fill:
            self.draw.draw_ellipse(xy, ink, 0, width)

    def line(self, xy, fill=None, width=0, joint=None):
        """Draw a line, or a connected sequence of line segments."""
        ink = self._getink(fill)[0]
        if ink is not None:
            self.draw.draw_lines(xy, ink, width)
            if joint == "curve" and width > 4:
                for i in range(1, len(xy) - 1):
                    point = xy[i]
                    angles = [
                        math.degrees(math.atan2(end[0] - start[0], start[1] - end[1]))
                        % 360
                        for start, end in ((xy[i - 1], point), (point, xy[i + 1]))
                    ]
                    if angles[0] == angles[1]:
                        # This is a straight line, so no joint is required
                        continue

                    def coord_at_angle(coord, angle):
                        x, y = coord
                        angle -= 90
                        distance = width / 2 - 1
                        return tuple(
                            [
                                p + (math.floor(p_d) if p_d > 0 else math.ceil(p_d))
                                for p, p_d in (
                                    (x, distance * math.cos(math.radians(angle))),
                                    (y, distance * math.sin(math.radians(angle))),
                                )
                            ]
                        )

                    flipped = (
                        angles[1] > angles[0] and angles[1] - 180 > angles[0]
                    ) or (angles[1] < angles[0] and angles[1] + 180 > angles[0])
                    coords = [
                        (point[0] - width / 2 + 1, point[1] - width / 2 + 1),
                        (point[0] + width / 2 - 1, point[1] + width / 2 - 1),
                    ]
                    if flipped:
                        start, end = (angles[1] + 90, angles[0] + 90)
                    else:
                        start, end = (angles[0] - 90, angles[1] - 90)
                    self.pieslice(coords, start - 90, end - 90, fill)

                    if width > 8:
                        # Cover potential gaps between the line and the joint
                        if flipped:
                            gapCoords = [
                                coord_at_angle(point, angles[0] + 90),
                                point,
                                coord_at_angle(point, angles[1] + 90),
                            ]
                        else:
                            gapCoords = [
                                coord_at_angle(point, angles[0] - 90),
                                point,
                                coord_at_angle(point, angles[1] - 90),
                            ]
                        self.line(gapCoords, fill, width=3)

    def shape(self, shape, fill=None, outline=None):
        """(Experimental) Draw a shape."""
        shape.close()
        ink, fill = self._getink(outline, fill)
        if fill is not None:
            self.draw.draw_outline(shape, fill, 1)
        if ink is not None and ink != fill:
            self.draw.draw_outline(shape, ink, 0)

    def pieslice(self, xy, start, end, fill=None, outline=None, width=0):
        """Draw a pieslice."""
        ink, fill = self._getink(outline, fill)
        if fill is not None:
            self.draw.draw_pieslice(xy, start, end, fill, 1)
        if ink is not None and ink != fill:
            self.draw.draw_pieslice(xy, start, end, ink, 0, width)

    def point(self, xy, fill=None):
        """Draw one or more individual pixels."""
        ink, fill = self._getink(fill)
        if ink is not None:
            self.draw.draw_points(xy, ink)

    def polygon(self, xy, fill=None, outline=None):
        """Draw a polygon."""
        ink, fill = self._getink(outline, fill)
        if fill is not None:
            self.draw.draw_polygon(xy, fill, 1)
        if ink is not None and ink != fill:
            self.draw.draw_polygon(xy, ink, 0)

    def rectangle(self, xy, fill=None, outline=None, width=0):
        """Draw a rectangle."""
        ink, fill = self._getink(outline, fill)
        if fill is not None:
            self.draw.draw_rectangle(xy, fill, 1)
        if ink is not None and ink != fill:
            self.draw.draw_rectangle(xy, ink, 0, width)

    def _multiline_check(self, text):
        """Draw text."""
        split_character = "\n" if isinstance(text, str) else b"\n"

        return split_character in text

    def _multiline_split(self, text):
        split_character = "\n" if isinstance(text, str) else b"\n"

        return text.split(split_character)

    def text(
        self,
        xy,
        text,
        fill=None,
        font=None,
        anchor=None,
        spacing=4,
        align="left",
        direction=None,
        features=None,
        language=None,
        stroke_width=0,
        stroke_fill=None,
        *args,
        **kwargs
    ):
        if self._multiline_check(text):
            return self.multiline_text(
                xy,
                text,
                fill,
                font,
                anchor,
                spacing,
                align,
                direction,
                features,
                language,
                stroke_width,
                stroke_fill,
            )

        if font is None:
            font = self.getfont()

        def getink(fill):
            ink, fill = self._getink(fill)
            if ink is None:
                return fill
            return ink

        def draw_text(ink, stroke_width=0, stroke_offset=None):
            coord = xy
            try:
                mask, offset = font.getmask2(
                    text,
                    self.fontmode,
                    direction=direction,
                    features=features,
                    language=language,
                    stroke_width=stroke_width,
                    *args,
                    **kwargs,
                )
                coord = coord[0] + offset[0], coord[1] + offset[1]
            except AttributeError:
                try:
                    mask = font.getmask(
                        text,
                        self.fontmode,
                        direction,
                        features,
                        language,
                        stroke_width,
                        *args,
                        **kwargs,
                    )
                except TypeError:
                    mask = font.getmask(text)
            if stroke_offset:
                coord = coord[0] + stroke_offset[0], coord[1] + stroke_offset[1]
            self.draw.draw_bitmap(coord, mask, ink)

        ink = getink(fill)
        if ink is not None:
            stroke_ink = None
            if stroke_width:
                stroke_ink = getink(stroke_fill) if stroke_fill is not None else ink

            if stroke_ink is not None:
                # Draw stroked text
                draw_text(stroke_ink, stroke_width)

                # Draw normal text
                draw_text(ink, 0, (stroke_width, stroke_width))
            else:
                # Only draw normal text
                draw_text(ink)

    def multiline_text(
        self,
        xy,
        text,
        fill=None,
        font=None,
        anchor=None,
        spacing=4,
        align="left",
        direction=None,
        features=None,
        language=None,
        stroke_width=0,
        stroke_fill=None,
    ):
        widths = []
        max_width = 0
        lines = self._multiline_split(text)
        line_spacing = (
            self.textsize("A", font=font, stroke_width=stroke_width)[1] + spacing
        )
        for line in lines:
            line_width, line_height = self.textsize(
                line,
                font,
                direction=direction,
                features=features,
                language=language,
                stroke_width=stroke_width,
            )
            widths.append(line_width)
            max_width = max(max_width, line_width)
        left, top = xy
        for idx, line in enumerate(lines):
            if align == "left":
                pass  # left = x
            elif align == "center":
                left += (max_width - widths[idx]) / 2.0
            elif align == "right":
                left += max_width - widths[idx]
            else:
                raise ValueError('align must be "left", "center" or "right"')
            self.text(
                (left, top),
                line,
                fill,
                font,
                anchor,
                direction=direction,
                features=features,
                language=language,
                stroke_width=stroke_width,
                stroke_fill=stroke_fill,
            )
            top += line_spacing
            left = xy[0]

    def textsize(
        self,
        text,
        font=None,
        spacing=4,
        direction=None,
        features=None,
        language=None,
        stroke_width=0,
    ):
        """Get the size of a given string, in pixels."""
        if self._multiline_check(text):
            return self.multiline_textsize(
                text, font, spacing, direction, features, language, stroke_width
            )

        if font is None:
            font = self.getfont()
        return font.getsize(text, direction, features, language, stroke_width)

    def multiline_textsize(
        self,
        text,
        font=None,
        spacing=4,
        direction=None,
        features=None,
        language=None,
        stroke_width=0,
    ):
        max_width = 0
        lines = self._multiline_split(text)
        line_spacing = (
            self.textsize("A", font=font, stroke_width=stroke_width)[1] + spacing
        )
        for line in lines:
            line_width, line_height = self.textsize(
                line, font, spacing, direction, features, language, stroke_width
            )
            max_width = max(max_width, line_width)
        return max_width, len(lines) * line_spacing - spacing


def Draw(im, mode=None):
    """
    A simple 2D drawing interface for PIL images.

    :param im: The image to draw in.
    :param mode: Optional mode to use for color values.  For RGB
       images, this argument can be RGB or RGBA (to blend the
       drawing into the image).  For all other modes, this argument
       must be the same as the image mode.  If omitted, the mode
       defaults to the mode of the image.
    """
    try:
        return im.getdraw(mode)
    except AttributeError:
        return ImageDraw(im, mode)


# experimental access to the outline API
try:
    Outline = Image.core.outline
except AttributeError:
    Outline = None


def getdraw(im=None, hints=None):
    """
    (Experimental) A more advanced 2D drawing interface for PIL images,
    based on the WCK interface.

    :param im: The image to draw in.
    :param hints: An optional list of hints.
    :returns: A (drawing context, drawing resource factory) tuple.
    """
    # FIXME: this needs more work!
    # FIXME: come up with a better 'hints' scheme.
    handler = None
    if not hints or "nicest" in hints:
      t‹ Ú° à” ¤ ° ° B¼ Oì dt‹ ‰° Ä ·Ô Ã° Éà ñğ şì t‹ 8° >ü f sì ˆt‹ ­° ³ Û( æğ ët‹ 	„ 	H (	€ R	„ W	ˆ m	4 {	L †	@ ’	¼‹ Ÿ	Ä‹ ¥	T µ	h Ä	Ì‹ Í	Ø‹ Ó	| ã	 ò	Ô‹ û	À‹ 
¤ 
¸  
Ì+ &
Ô 4
è Y
@  x  l‹ & \ ? Ì D l‹ T p‹ f x r d š t‹ Ÿ Ì‹ ¥ Ø‹ µ x Ì Ì‹ ø l‹ ş Ğ‹ p‹ 2x ?l‹ I\ bĞ gl‹ wp‹ ‰x •d ½t‹ Â¼‹ ÈÄ‹ Øx ï¼‹ l‹ !Ğ‹ 8p‹ Ux bl‹ l\ …Ô Šl‹ ™Ø p‹ ´¬ ¹t‹ ×x‹ àl‹ èx p‹ !x .l‹ 8\ QÜ Vl‹ dH np‹ t‹ —l‹ ®p‹ Æl‹ Ûl‹ Ä‹ Ø‹ À‹ L "¼‹ 'Ì‹ ,Ô‹ 6L At‹ PÔ‹ YÀ‹ _h và {x‹ †Ì‹ Ø‹;	PO D	TO I	O Q	`O W	ŒO ]	\O ñ
˜X µ˜X Y˜X ı˜X —˜X ‹˜X  ÿÿ0 
 ğ $ 0 K ğ |  ± €X Ş lX ü lX  ˆ ¨â‰ ¾P AP WPˆxX ˆX ›ˆX ­xX ·pX ËpX ÔˆX ñ´  ´ 6xX <ˆX hxX qˆX {pX ŠpX ÄX 4ÄX mŒX “ŒX œŒX ²ŒX »€X Ã°X ı€X 	€X ÏdO Ø˜X QdO W4O ehO k8O lO £<O ÍtO ÓDO áxO çHO ù|O şLO 	ˆO 	ˆO 	XO  	pO %	@O 1	„O 6	€O 2ŒX 8˜X =¸X W„X „tX Š X tX œhX »´X Â´ ÖÀX ã˜X é¨X õ¤X ¬X  ÀX &¨X 6¤X Q¬X aÀX g¨X y¤X …¬X ÀX 8O +<O 6HO A¤X FDO PLO gTO t¨X yXO …\O ’¬X ì4Z ó4a ùpX ÿxX ˆX pX #8Z /0Z >pX IpX w8Z ~8Z ›8Z ²8Z ¹8Z À8Z Ç8Z Ñ4Z Ü<Z æ4Z î<Z !pX &4Z  @8f°X nÄX w„X |ŒX ŠX ”X © X µœX ¿€X ÄdX Î|X ÓlX ÛX øtX ş X tX dO ¼X hX "ÄX (ÈX -ÌX s˜X ÛœX òœX 	œX 'PO ,˜X :@O E`O –˜X  œˆ+´ &X ,˜X 5”X  E(í X tX  3$?dW  D$RdW W¼X vÌX “ÈX ´¸X  X »tX ä¼X ÿÌX ÈX =¸X ´´  º,À˜X  Ê(j X ÌtX âX õ”X  û, $äW &äV L¼X gÌX ÈX ¡¸X }	 X ß	tX õ	X 
”X 
¼X *
ÌX G
ÈX c
¸X É
ÒX Ò
ĞX 4O ÿxX 	ˆX c	ˆX