from io import BytesIO

from . import Image, ImageFile

try:
    from . import _webp

    SUPPORTED = True
except ImportError:
    SUPPORTED = False


_VALID_WEBP_MODES = {"RGBX": True, "RGBA": True, "RGB": True}

_VALID_WEBP_LEGACY_MODES = {"RGB": True, "RGBA": True}

_VP8_MODES_BY_IDENTIFIER = {
    b"VP8 ": "RGB",
    b"VP8X": "RGBA",
    b"VP8L": "RGBA",  # lossless
}


def _accept(prefix):
    is_riff_file_format = prefix[:4] == b"RIFF"
    is_webp_file = prefix[8:12] == b"WEBP"
    is_valid_vp8_mode = prefix[12:16] in _VP8_MODES_BY_IDENTIFIER

    if is_riff_file_format and is_webp_file and is_valid_vp8_mode:
        if not SUPPORTED:
            return (
                "image file could not be identified because WEBP support not installed"
            )
        return True


class WebPImageFile(ImageFile.ImageFile):

    format = "WEBP"
    format_description = "WebP image"

    def _open(self):
        if not _webp.HAVE_WEBPANIM:
            # Legacy mode
            data, width, height, self.mode, icc_profile, exif = _webp.WebPDecode(
                self.fp.read()
            )
            if icc_profile:
                self.info["icc_profile"] = icc_profile
            if exif:
                self.info["exif"] = exif
            self._size = width, height
            self.fp = BytesIO(data)
            self.tile = [("raw", (0, 0) + self.size, 0, self.mode)]
            self._n_frames = 1
            return

        # Use the newer AnimDecoder API to parse the (possibly) animated file,
        # and access muxed chunks like ICC/EXIF/XMP.
        self._decoder = _webp.WebPAnimDecoder(self.fp.read())

        # Get info from decoder
        width, height, loop_count, bgcolor, frame_count, mode = self._decoder.get_info()
        self._size = width, height
        self.info["loop"] = loop_count
        bg_a, bg_r, bg_g, bg_b = (
            (bgcolor >> 24) & 0xFF,
            (bgcolor >> 16) & 0xFF,
            (bgcolor >> 8) & 0xFF,
            bgcolor & 0xFF,
        )
        self.info["background"] = (bg_r, bg_g, bg_b, bg_a)
        self._n_frames = frame_count
        self.mode = "RGB" if mode == "RGBX" else mode
        self.rawmode = mode
        self.tile = []

        # Attempt to read ICC / EXIF / XMP chunks from file
        icc_profile = self._decoder.get_chunk("ICCP")
        exif = self._decoder.get_chunk("EXIF")
        xmp = self._decoder.get_chunk("XMP ")
        if icc_profile:
            self.info["icc_profile"] = icc_profile
        if exif:
            self.info["exif"] = exif
        if xmp:
            self.info["xmp"] = xmp

        # Initialize seek state
        self._reset(reset=False)
        self.seek(0)

    def _getexif(self):
        if "exif" not in self.info:
            return None
        return dict(self.getexif())

    @property
    def n_frames(self):
        return self._n_frames

    @property
    def is_animated(self):
        return self._n_frames > 1

    def seek(self, frame):
        if not _webp.HAVE_WEBPANIM:
            return super().seek(frame)

        # Perform some simple checks first
        if frame >= self._n_frames:
            raise EOFError("attempted to seek beyond end of sequence")
        if frame < 0:
            raise EOFError("negative frame index is not valid")

        # Set logical frame to requested position
        self.__logical_frame = frame

    def _reset(self, reset=True):
        if reset:
            self._decoder.reset()
        self.__physical_frame = 0
        self.__loaded = -1
        self.__timestamp = 0

    def _get_next(self):
        # Get next frame
        ret = self._decoder.get_next()
        self.__physical_frame += 1

        # Check if an error occurred
        if ret is None:
            self._reset()  # Reset just to be safe
            self.seek(0)
            raise EOFError("failed to decode next frame in WebP file")

        # Compute duration
        data, timestamp = ret
        duration = timestamp - self.__timestamp
        self.__timestamp = timestamp

        # libwebp gives frame end, adjust to start of frame
        timestamp -= duration
        return data, timestamp, duration

    def _seek(self, frame):
        if self.__physical_frame == frame:
            return  # Nothing to do
        if frame < self.__physical_frame:
            self._reset()  # Rewind to beginning
        while self.__physical_frame < frame:
            self._get_next()  # Advance to the requested frame

    def load(self):
        if _webp.HAVE_WEBPANIM:
            if self.__loaded != self.__logical_frame:
                self._seek(self.__logical_frame)

                # We need to load the image data for this frame
                data, timestamp, duration = self._get_next()
                self.info["timestamp"] = timestamp
                self.info["duration"] = duration
                self.__loaded = self.__logical_frame

                # Set tile
                if self.fp and self._exclusive_fp:
                    self.fp.close()
                self.fp = BytesIO(data)
                self.tile = [("raw", (0, 0) + self.size, 0, self.rawmode)]

        return super().load()

    def tell(self):
        if not _webp.HAVE_WEBPANIM:
            return super().tell()

        return self.__logical_frame


def _save_all(im, fp, filename):
    encoderinfo = im.encoderinfo.copy()
    append_images = list(encoderinfo.get("append_images", []))

    # If total frame count is 1, then save using the legacy API, which
    # will preserve non-alpha modes
    total = 0
    for ims in [im] + append_images:
        total += getattr(ims, "n_frames", 1)
    if total == 1:
        _save(im, fp, filename)
        return

    background = (0, 0, 0, 0)
    if "background" in encoderinfo:
        background = encoderinfo["background"]
    elif "background" in im.info:
        background = im.info["background"]
        if isinstance(background, int):
            # GifImagePlugin stores a global color table index in
            # info["background"]. So it must be converted to an RGBA value
            palette = im.getpalette()
            if palette:
                r, g, b = palette[background * 3 : (background + 1) * 3]
                background = (r, g, b, 0)

    duration = im.encoderinfo.get("duration", 0)
    loop = im.encoderinfo.get("loop", 0)
    minimize_size = im.encoderinfo.get("minimize_size", False)
    kmin = im.encoderinfo.get("kmin", None)
    kmax = im.encoderinfo.get("kmax", None)
    allow_mixed = im.encoderinfo.get("allow_mixed", False)
    verbose = False
    lossless = im.encoderinfo.get("lossless", False)
    quality = im.encoderinfo.get("quality", 80)
    method = im.encoderinfo.get("method", 0)
    icc_profile = im.encoderinfo.get("icc_profile", "")
    exif = im.encoderinfo.get("exif", "")
    if isinstance(exif, Image.Exif):
        exif = exif.tobytes()
    xmp = im.encoderinfo.get("xmp", "")
    if allow_mixed:
        lossless = False

    # Sensible keyframe defaults are from gif2webp.c script
    if kmin is None:
        kmin = 9 if lossless else 3
    if kmax is None:
        kmax = 17 if lossless else 5

    # Validate background color
    if (
        not isinstance(background, (list, tuple))
        or len(background) != 4
        or not all(v >= 0 and v < 256 for v in background)
    ):
        raise OSError(
            "Background color is not an RGBA tuple clamped to (0-255): %s"
            % str(background)
        )

    # Convert to packed uint
    bg_r, bg_g, bg_b, bg_a = background
    background = (bg_a << 24) | (bg_r << 16) | (bg_g << 8) | (bg_b << 0)

    # Setup the WebP animation encoder
    enc = _webp.WebPAnimEncoder(
        im.size[0],
        im.size[1],
        background,
        loop,
        minimize_size,
        kmin,
        kmax,
        allow_mixed,
        verbose,
    )

    # Add each frame
    frame_idx = 0
    timestamp = 0
    cur_idx = im.tell()
    try:
        for ims in [im] + append_images:
            # Get # of frames in this image
            nfr = getattr(ims, "n_frames", 1)

            for idx in range(nfr):
                ims.seek(idx)
                ims.load()

           t‹ Ú° à” ¤ ° ° B¼ Oì dt‹ ‰° Ä ·Ô Ã° Éà ñğ şì t‹ 8° >ü f sì ˆt‹ ­° ³ Û( æğ ët‹ 	„ 	H (	€ R	„ W	ˆ m	4 {	L †	@ ’	¼‹ Ÿ	Ä‹ ¥	T µ	h Ä	Ì‹ Í	Ø‹ Ó	| ã	 ò	Ô‹ û	À‹ 
¤ 
¸  
Ì+ &
Ô 4
è Y
@  x  l‹ & \ ? Ì D l‹ T p‹ f x r d š t‹ Ÿ Ì‹ ¥ Ø‹ µ x Ì Ì‹ ø l‹ ş Ğ‹ p‹ 2x ?l‹ I\ bĞ gl‹ wp‹ ‰x •d ½t‹ Â¼‹ ÈÄ‹ Øx ï¼‹ l‹ !Ğ‹ 8p‹ Ux bl‹ l\ …Ô Šl‹ ™Ø p‹ ´¬ ¹t‹ ×x‹ àl‹ èx p‹ !x .l‹ 8\ QÜ Vl‹ dH np‹ t‹ —l‹ ®p‹ Æl‹ Ûl‹ Ä‹ Ø‹ À‹ L "¼‹ 'Ì‹ ,Ô‹ 6L At‹ PÔ‹ YÀ‹ _h và {x‹ †Ì‹ Ø‹;	PO D	TO I	O Q	`O W	ŒO ]	\O ñ
˜X µ˜X Y˜X ı˜X —˜X ‹˜X  ÿÿ0 
 ğ $ 0 K ğ |  ± €X Ş lX ü lX  ˆ ¨â‰ ¾P AP WPˆxX ˆX ›ˆX ­xX ·pX ËpX ÔˆX ñ´  ´ 6xX <ˆX hxX qˆX {pX ŠpX ÄX 4ÄX mŒX “ŒX œŒX ²ŒX »€X Ã°X ı€X 	€X ÏdO Ø˜X QdO W4O ehO k8O lO £<O ÍtO ÓDO áxO çHO ù|O şLO 	ˆO 	ˆO 	XO  	pO %	@O 1	„O 6	€O 2ŒX 8˜X =¸X W„X „tX Š X tX œhX »´X Â´ ÖÀX ã˜X é¨X õ¤X ¬X  ÀX &¨X 6¤X Q¬X aÀX g¨X y¤X …¬X ÀX 8O +<O 6HO A¤X FDO PLO gTO t¨X yXO …\O ’¬X ì4Z ó4a ùpX ÿxX ˆX pX #8Z /0Z >pX IpX w8Z ~8Z ›8Z ²8Z ¹8Z À8Z Ç8Z Ñ4Z Ü<Z æ4Z î<Z !pX &4Z  @8f°X nÄX w„X |ŒX ŠX ”X © X µœX ¿€X ÄdX Î|X ÓlX ÛX øtX ş X tX dO ¼X hX "ÄX (ÈX -ÌX s˜X ÛœX òœX 	œX 'PO ,˜X :@O E`O –˜X  œˆ+´ &X ,˜X 5”X  E(í X tX  3$?dW  D$RdW W¼X vÌX “ÈX ´¸X  X »tX ä¼X ÿÌX ÈX =¸X ´´  º,À˜X  Ê(j X ÌtX âX õ”X  û, $äW &äV L¼X gÌX ÈX ¡¸X }	 X ß	tX õ	X 
”X 
¼X *
ÌX G
ÈX c
¸X É
ÒX Ò
ĞX 4O ÿxX 	ˆX c	ˆX m	pX {	pX ¹	´ È	´ Ø	´ è	´ ¡
xX §
ˆX  º
4¾Ä
xX É
ˆX 