#
# The Python Imaging Library.
# $Id$
#
# macOS icns file decoder, based on icns.py by Bob Ippolito.
#
# history:
# 2004-10-09 fl   Turned into a PIL plugin; removed 2.3 dependencies.
#
# Copyright (c) 2004 by Bob Ippolito.
# Copyright (c) 2004 by Secret Labs.
# Copyright (c) 2004 by Fredrik Lundh.
# Copyright (c) 2014 by Alastair Houghton.
#
# See the README file for information on usage and redistribution.
#

import io
import os
import shutil
import struct
import subprocess
import sys
import tempfile

from PIL import Image, ImageFile, PngImagePlugin
from PIL._binary import i8

enable_jpeg2k = hasattr(Image.core, "jp2klib_version")
if enable_jpeg2k:
    from PIL import Jpeg2KImagePlugin

HEADERSIZE = 8


def nextheader(fobj):
    return struct.unpack(">4sI", fobj.read(HEADERSIZE))


def read_32t(fobj, start_length, size):
    # The 128x128 icon seems to have an extra header for some reason.
    (start, length) = start_length
    fobj.seek(start)
    sig = fobj.read(4)
    if sig != b"\x00\x00\x00\x00":
        raise SyntaxError("Unknown signature, expecting 0x00000000")
    return read_32(fobj, (start + 4, length - 4), size)


def read_32(fobj, start_length, size):
    """
    Read a 32bit RGB icon resource.  Seems to be either uncompressed or
    an RLE packbits-like scheme.
    """
    (start, length) = start_length
    fobj.seek(start)
    pixel_size = (size[0] * size[2], size[1] * size[2])
    sizesq = pixel_size[0] * pixel_size[1]
    if length == sizesq * 3:
        # uncompressed ("RGBRGBGB")
        indata = fobj.read(length)
        im = Image.frombuffer("RGB", pixel_size, indata, "raw", "RGB", 0, 1)
    else:
        # decode image
        im = Image.new("RGB", pixel_size, None)
        for band_ix in range(3):
            data = []
            bytesleft = sizesq
            while bytesleft > 0:
                byte = fobj.read(1)
                if not byte:
                    break
                byte = i8(byte)
                if byte & 0x80:
                    blocksize = byte - 125
                    byte = fobj.read(1)
                    for i in range(blocksize):
                        data.append(byte)
                else:
                    blocksize = byte + 1
                    data.append(fobj.read(blocksize))
                bytesleft -= blocksize
                if bytesleft <= 0:
                    break
            if bytesleft != 0:
                raise SyntaxError("Error reading channel [%r left]" % bytesleft)
            band = Image.frombuffer("L", pixel_size, b"".join(data), "raw", "L", 0, 1)
            im.im.putband(band.im, band_ix)
    return {"RGB": im}


def read_mk(fobj, start_length, size):
    # Alpha masks seem to be uncompressed
    start = start_length[0]
    fobj.seek(start)
    pixel_size = (size[0] * size[2], size[1] * size[2])
    sizesq = pixel_size[0] * pixel_size[1]
    band = Image.frombuffer("L", pixel_size, fobj.read(sizesq), "raw", "L", 0, 1)
    return {"A": band}


def read_png_or_jpeg2000(fobj, start_length, size):
    (start, length) = start_length
    fobj.seek(start)
    sig = fobj.read(12)
    if sig[:8] == b"\x89PNG\x0d\x0a\x1a\x0a":
        fobj.seek(start)
        im = PngImagePlugin.PngImageFile(fobj)
        return {"RGBA": im}
    elif (
        sig[:4] == b"\xff\x4f\xff\x51"
        or sig[:4] == b"\x0d\x0a\x87\x0a"
        or sig == b"\x00\x00\x00\x0cjP  \x0d\x0a\x87\x0a"
    ):
        if not enable_jpeg2k:
            raise ValueError(
                "Unsupported icon subimage format (rebuild PIL "
                "with JPEG 2000 support to fix this)"
            )
        # j2k, jpc or j2c
        fobj.seek(start)
        jp2kstream = fobj.read(length)
        f = io.BytesIO(jp2kstream)
        im = Jpeg2KImagePlugin.Jpeg2KImageFile(f)
        if im.mode != "RGBA":
            im = im.convert("RGBA")
        return {"RGBA": im}
    else:
        raise ValueError("Unsupported icon subimage format")


class IcnsFile:

    SIZES = {
        (512, 512, 2): [(b"ic10", read_png_or_jpeg2000)],
        (512, 512, 1): [(b"ic09", read_png_or_jpeg2000)],
        (256, 256, 2): [(b"ic14", read_png_or_jpeg2000)],
        (256, 256, 1): [(b"ic08", read_png_or_jpeg2000)],
        (128, 128, 2): [(b"ic13", read_png_or_jpeg2000)],
        (128, 128, 1): [
            (b"ic07", read_png_or_jpeg2000),
            (b"it32", read_32t),
            (b"t8mk", read_mk),
        ],
        (64, 64, 1): [(b"icp6", read_png_or_jpeg2000)],
        (32, 32, 2): [(b"ic12", read_png_or_jpeg2000)],
        (48, 48, 1): [(b"ih32", read_32), (b"h8mk", read_mk)],
        (32, 32, 1): [
            (b"icp5", read_png_or_jpeg2000),
            (b"il32", read_32),
            (b"l8mk", read_mk),
        ],
        (16, 16, 2): [(b"ic11", read_png_or_jpeg2000)],
        (16, 16, 1): [
            (b"icp4", read_png_or_jpeg2000),
            (b"is32", read_32),
            (b"s8mk", read_mk),
        ],
    }

    def __init__(self, fobj):
        """
        fobj is a file-like object as an icns resource
        """
        # signature : (start, length)
        self.dct = dct = {}
        self.fobj = fobj
        sig, filesize = nextheader(fobj)
        if sig != b"icns":
            raise SyntaxError("not an icns file")
        i = HEADERSIZE
        while i < filesize:
            sig, blocksize = nextheader(fobj)
            if blocksize <= 0:
                raise SyntaxError("invalid block header")
            i += HEADERSIZE
            blocksize -= HEADERSIZE
            dct[sig] = (i, blocksize)
            fobj.seek(blocksize, io.SEEK_CUR)
            i += blocksize

    def itersizes(self):
        sizes = []
        for size, fmts in self.SIZES.items():
            for (fmt, reader) in fmts:
                if fmt in self.dct:
                    sizes.append(size)
                    break
        return sizes

    def bestsize(self):
        sizes = self.itersizes()
        if not sizes:
            raise SyntaxError("No 32bit icon resources found")
        return max(sizes)

    def dataforsize(self, size):
        """
        Get an icon resource as {channel: array}.  Note that
        the arrays are bottom-up like windows bitmaps and will likely
        need to be flipped or transposed in some way.
        """
        dct = {}
        for code, reader in self.SIZES[size]:
            desc = self.dct.get(code)
            if desc is not None:
                dct.update(reader(self.fobj, desc, size))
        return dct

    def getimage(self, size=None):
        if size is None:
            size = self.bestsize()
        if len(size) == 2:
            size = (size[0], size[1], 1)
        channels = self.dataforsize(size)

        im = channels.get("RGBA", None)
        if im:
            return im

        im = channels.get("RGB").copy()
        try:
            im.putalpha(channels["A"])
        except KeyError:
            pass
        return im


##
# Image plugin for Mac OS icons.


class IcnsImageFile(ImageFile.ImageFile):
    """
    PIL image support for Mac OS .icns files.
    Chooses the best resolution, but will possibly load
    a different size image if you mutate the size attribute
    before calling 'load'.

    The info dictionary has a key 'sizes' that is a list
    of sizes that the icns file has.
    """

    format = "ICNS"
    format_description = "Mac OS icns resource"

    def _open(self):
        self.icns = IcnsFile(self.fp)
        self.mode = "RGBA"
        self.info["sizes"] = self.icns.itersizes()
        self.best_size = self.icns.bestsize()
        self.size = (
            self.best_size[0] * self.best_size[2],
            self.best_size[1] * self.best_size[2],
        )

    @property
    def size(self):
        return self._size

    @size.setter
    def size(self, value):
        info_size = value
        if info_size not in self.info["sizes"] and len(info_size) == 2:
            info_size = (info_size[0], info_size[1], 1)
        if (
            info_size not in self.info["sizes"]
            and len(info_size) == 3
            and info_size[2] == 1
        ):
            simple_sizes = [
                (size[0] * size[2], size[1] * size[2]±Ğì4Á€Øh*
…À=YÑe–~¦Š<Íâp}9–-èD±Üø‚Sòdñ·	Ì'ÛXGß"¼¼Í»ÆùTDJ.?Ñƒ‚‰ ±etàk&İäÇç!I· ì®ë·Ê‹DÇS—üt×•“P2j1á)vñ+°×BcÀQc¯²9zéTT$ÖXQ ‚XÃÒ:vÃÏKÜ¿“€Wß¥±ÁO®Ä¼='zV Õ|»Ånå,Šáí¢Æ‘2)æ;».=_)ÊZ-ôÎwÎx«î]ûŒYµZŠ­Ø·ÎÕïıƒ.ÀÇÿ^ôùúVÓ;
6ÑÎ.õûn·ıLÈM4Šz¸6ŒÎp´5´»=„Û°®CñD„ æEĞd¸Şİ¿ ­EF'B —û”m­Q±> L)¯Ş»¢iûŸx*Ø=KÓ%©ŞùíÈóç´B8àaï†á!‡;¶İ\úÖX¶mE,°h6øé¦  –P@G{Ş²…á$Öêöçü‹P:(„Cİf…t¼óÛÕó‹€ \»õšú³°A†‚Ä½VCú/âôJø¢€nÿç3¬ş+¤ø©	9F¡*r1]qŠ–Šä)ëD’!š±:$a5Ğ˜¥Lr‡HÑ[ÒÕCMz™-’`ÖJˆaùÿñL€?@ 'TôéA°Ğl4+
Â  È,†Ã! °H(
ƒäÙôY„<š4hü6x>‹/W!ğ2B"ŸéX	ğaÁÙÈ ;µ%ÂŒFŒÖö ü£’dçx$ª]ï!$Ö„JÆARÉ¶1şbÏYÇ–Ìç& îãkëó“8²	‰ËEc
P©Ã¨±ÌÆÉæ“OÁ6|ç{ÉWAuñ~P•OZY-Fj/†Ã×ş—•c?ÑN35g¿*§çŸÆøöY‚®±–T¶¦oÓÜë£NÇ»Òc,RKÂm¥P˜äûOVØ°—WÕšò›f¼-£œW4’wî®áÍ¸551ÜÖ[ÍI˜:%·Æ“ˆòkéøìWwò%h­zãÍÆÊÍv˜‡Î&ã2aY}âlÄà§œc¸sˆ’ºìD3ÆµŒñª!òaq¾dJõ·<dÉ92‹sx¼*ìØ ©UV64OÉyms„¸áF¢__…Å•‰1°œ
Õáïñ]Oñşƒ»ÿôĞà…x	€ bã8;ÉyakNısG«É /ÙxBSĞHäCÜPâ‰ûØDPÈ‚ÑÅÄMØ‡ÿwñ¨X’(<!²V]Bı÷İÌOhn“F”`Š"V¦¢ÆaPa!Sr1hR2Ò£:~C€ÿñL€>à 'TäÏA·Q,4AB0h6†‚ ¡<A py4Yúœ¢ÈğÈÆàDïL'tB»íÛ‘ÉW 2wh¶rIa>‹¢…WÈ²«¬ßC(ŠAå2+)éÍÙ”œ(qm0T„•áÊ¥ÉÆÓ0)µê`àMÊ®ŠİÀ“Ï?÷¸ù\*r¢¨¤opt ;ÏMi=«¯ú’VŞ mhLªª­Ğ|ë ıkö.“Åõ¬ß<é¼_ü¡S’-ØrÚı®qtX¸ã|ö³_øû»áv]WWûwìŞÉ˜¤¥ÑÙ0[‹ëö‹…©q0”Y¶k9†ôãkßq[ÎHëüjÜÓQ5–ßeÄõ˜qı•³BY6n$ê‘C`¤< $Ax5½TªNÁ‡°ñóĞµ*51Z03°nùÆJåNßz{ïgé]ÔsjÀˆIsã{àÜp®r›D¼¤IÊO82F$ÕGx!R­müâÀ  ÆúĞıú>½~£~µÂşºbîºÑöîÿñïgës"ª‹Ä¼¸‘’Ì	DG"Z'.ïwô–íÃ"Ês:{wµ “%ægtÖlê ‚|s!fqP#I‡G¶rÍùä\«R’cû—
œ	¡nëZ#
ÇIQCÈpÿñL€?€ 'TåïC°Ğ`4	áØd6Ñ‡@è¢Ï&©g'gÑ`Hô¢ J4	şIw) ’r™Ğö&–]6OË’ê9+¼òˆ:ŠçŞ›]]!€)1˜–î(&§ê`ø´ª¢oÄ	gÀÿÕ|ºÚÀÏo\-Š?ÁçXt)¿ã]º¸¿ÎÉ”¥XÙ±»ê„%JJ(d[ï;Ç=¸‘LMğn¸ø .Jàù{^·¹Îz”B’‡bÂ3»ê/Ñßzì>b’<­Áe«¸z'â6.Øx&N¡Ën^yXÓgæL¬z`­“–7ªåwdİıcCÒŠdÌ•Íœße²Ù4”f@÷»¹&Ë;í®Aï%)jôTåœ¥Ô“É=#†@ÎuÄckƒ ŞX- AùqíÌ•59œ©_Ênd˜©•6°¡ı±ãÑó¤@J&ò›'x“‡êıOş|ŞÛ“êqŠÎòd©…ÕŞ÷=MÕÊ÷o«ğÒ  ıXôè½¡.ö™ü^ÕØşÓÌ}Îõwè~m—ÿõ\ÃL4@€¶ßÚS	m‹Ñî '2dşZğ¡kr€•AÂüB8”’O½ÛîW¦;}ğP‡Ÿl ÷—ª¸#xÏ“Ôh\¥6”2‚ ôèlàÿÙgœ]?!ÀÿñL€=à 'TëÏA·Pl4+A@l…Ã!a!}M¢?SFÏGÑ )ü“‰†±Q“,ÃuÍ’H"ÁZ %C)ãÙÖ1KÚfpz¿íğuE­*ó$LîªdZŒTH]?w%Tı]B†¥-5ƒ‡+‡MÈÿÔäûÛf}åÉ”ÿ·û?Mı‹„ˆcÏ«&…Kl”CŞÍ1¨È9ù4„‚ ÌrÑò?÷ëHü»/É>É­*Œ£ÍóM™š"4ft!€‡XÃºvŒ¡ı™®9Ê?™Âw&´lçˆÒ˜|\3nc·Ì4]ˆ¬Ó¢i?¤Ïd|?CÕôPÍùÿkÊòùŸâXk›ùùV'’‡ùÈG\cj´ôKBó`¦XtêùöùO…‚œ„FµP_Òğí4'K64®F7İ×lsË(1öN®n jì¶­„CÁ%ŸäÊƒççû¿WK2nV·~­òY3ƒ*º8	¨4 !”•~³mél&…  &¬?Í©?Nşû™ƒàğï­Ç£ç»¿¤áL³™ÕşVúj³oIĞP¨Š¼ºº·ÌbZùŠ¹_fËªè@&!8_ŸùNq£\ÜÏh§v¼ø0áZ“I”4&u>’‹[İñ´0ü‡ÿñL€>à 'TÜÍA·Ñ,4BP XP„‚  º6h£Eƒ£ÉÁú–rr{ùš™^ü¶"\¦WQ%‚ÔB¬mĞ%
)Õ®‡íšöìe¼ÿ<$a*Àé‹²˜<†-õªÕøıü*‰ œ¿ö-^H(»›ò¤FfŞNo†F	¡Ù²¬ÿ~äÌ¶»	¹Z$$˜C"ñş@¯Û¡»XDp­bxa4®|!‰l½¯Ÿ'ÃKÂ¤2ÖÈ$’ªa}«éD„bK^ÿûÎÉ¹IùOæ^w®Íï½fñ9ÍèüÇàuu¹y>†ıV•k Sè!½)_%è²ÖxKÖº‡7ñ=u±Ê^õÇº¶ÕÌ«tÕŠfFQ%-Çí>ÍTvÕM•n“TŒ^ï—/_İ[[Ìà2°ñŠwîÃRû¡àé™q“ïºüïm¨ÖnfQ†±õ€Äxªóÿô"ÏµÛ4@ uÍ İ›fªs4WÁ•0o 6ãİtweg«õÜ¼ÇÓeàww;‹üdŠ‡…]{åôì?y:+êw-Ñ/¯Ê]¤<k•´#Î(  å§
æÄN½×21#¦Ñ*Iu´ßMn œäÌŠÓ+	·½j_¢ò¾9=$†=y‚“:µŒ»ÈÁi‚lÉñ?!ÀÿñL€@` 'TåÍA·Àhv	Á€Èl2ƒÑ‡“g’%œƒFÏÁd?‰[g‰”êgÉqÚy<2H Y^©=øH¸³ã.ƒñÿ°–äT¥É{ i]ù\†2 ‘?ƒ&Y&AÁ³Ÿ^WKş‘ˆ-Øô¸ñÛ˜ˆÑúÂ`‚@cÈ`ÈIÏ— ‹&”÷Ú_ä© LÃëlÍª½†r”î¨|~)ÎÃë,ùî™T}‰ÆÖi±×Xåşéá’»æañKÒ©Ûğ=NÕŞŞoÿxè4¯Õ·Ô­­>SÆ:¾*¥®jıvÙÉ`$2ªänmâ)e}Í“Î5}c