#
# The Python Imaging Library.
# $Id$
#
# standard image operations
#
# History:
# 2001-10-20 fl   Created
# 2001-10-23 fl   Added autocontrast operator
# 2001-12-18 fl   Added Kevin's fit operator
# 2004-03-14 fl   Fixed potential division by zero in equalize
# 2005-05-05 fl   Fixed equalize for low number of values
#
# Copyright (c) 2001-2004 by Secret Labs AB
# Copyright (c) 2001-2004 by Fredrik Lundh
#
# See the README file for information on usage and redistribution.
#

import functools
import operator

from . import Image

#
# helpers


def _border(border):
    if isinstance(border, tuple):
        if len(border) == 2:
            left, top = right, bottom = border
        elif len(border) == 4:
            left, top, right, bottom = border
    else:
        left = top = right = bottom = border
    return left, top, right, bottom


def _color(color, mode):
    if isinstance(color, str):
        from . import ImageColor

        color = ImageColor.getcolor(color, mode)
    return color


def _lut(image, lut):
    if image.mode == "P":
        # FIXME: apply to lookup table, not image data
        raise NotImplementedError("mode P support coming soon")
    elif image.mode in ("L", "RGB"):
        if image.mode == "RGB" and len(lut) == 256:
            lut = lut + lut + lut
        return image.point(lut)
    else:
        raise OSError("not supported for this image mode")


#
# actions


def autocontrast(image, cutoff=0, ignore=None):
    """
    Maximize (normalize) image contrast. This function calculates a
    histogram of the input image, removes **cutoff** percent of the
    lightest and darkest pixels from the histogram, and remaps the image
    so that the darkest pixel becomes black (0), and the lightest
    becomes white (255).

    :param image: The image to process.
    :param cutoff: How many percent to cut off from the histogram.
    :param ignore: The background pixel value (use None for no background).
    :return: An image.
    """
    histogram = image.histogram()
    lut = []
    for layer in range(0, len(histogram), 256):
        h = histogram[layer : layer + 256]
        if ignore is not None:
            # get rid of outliers
            try:
                h[ignore] = 0
            except TypeError:
                # assume sequence
                for ix in ignore:
                    h[ix] = 0
        if cutoff:
            # cut off pixels from both ends of the histogram
            # get number of pixels
            n = 0
            for ix in range(256):
                n = n + h[ix]
            # remove cutoff% pixels from the low end
            cut = n * cutoff // 100
            for lo in range(256):
                if cut > h[lo]:
                    cut = cut - h[lo]
                    h[lo] = 0
                else:
                    h[lo] -= cut
                    cut = 0
                if cut <= 0:
                    break
            # remove cutoff% samples from the hi end
            cut = n * cutoff // 100
            for hi in range(255, -1, -1):
                if cut > h[hi]:
                    cut = cut - h[hi]
                    h[hi] = 0
                else:
                    h[hi] -= cut
                    cut = 0
                if cut <= 0:
                    break
        # find lowest/highest samples after preprocessing
        for lo in range(256):
            if h[lo]:
                break
        for hi in range(255, -1, -1):
            if h[hi]:
                break
        if hi <= lo:
            # don't bother
            lut.extend(list(range(256)))
        else:
            scale = 255.0 / (hi - lo)
            offset = -lo * scale
            for ix in range(256):
                ix = int(ix * scale + offset)
                if ix < 0:
                    ix = 0
                elif ix > 255:
                    ix = 255
                lut.append(ix)
    return _lut(image, lut)


def colorize(image, black, white, mid=None, blackpoint=0, whitepoint=255, midpoint=127):
    """
    Colorize grayscale image.
    This function calculates a color wedge which maps all black pixels in
    the source image to the first color and all white pixels to the
    second color. If **mid** is specified, it uses three-color mapping.
    The **black** and **white** arguments should be RGB tuples or color names;
    optionally you can use three-color mapping by also specifying **mid**.
    Mapping positions for any of the colors can be specified
    (e.g. **blackpoint**), where these parameters are the integer
    value corresponding to where the corresponding color should be mapped.
    These parameters must have logical order, such that
    **blackpoint** <= **midpoint** <= **whitepoint** (if **mid** is specified).

    :param image: The image to colorize.
    :param black: The color to use for black input pixels.
    :param white: The color to use for white input pixels.
    :param mid: The color to use for midtone input pixels.
    :param blackpoint: an int value [0, 255] for the black mapping.
    :param whitepoint: an int value [0, 255] for the white mapping.
    :param midpoint: an int value [0, 255] for the midtone mapping.
    :return: An image.
    """

    # Initial asserts
    assert image.mode == "L"
    if mid is None:
        assert 0 <= blackpoint <= whitepoint <= 255
    else:
        assert 0 <= blackpoint <= midpoint <= whitepoint <= 255

    # Define colors from arguments
    black = _color(black, "RGB")
    white = _color(white, "RGB")
    if mid is not None:
        mid = _color(mid, "RGB")

    # Empty lists for the mapping
    red = []
    green = []
    blue = []

    # Create the low-end values
    for i in range(0, blackpoint):
        red.append(black[0])
        green.append(black[1])
        blue.append(black[2])

    # Create the mapping (2-color)
    if mid is None:

        range_map = range(0, whitepoint - blackpoint)

        for i in range_map:
            red.append(black[0] + i * (white[0] - black[0]) // len(range_map))
            green.append(black[1] + i * (white[1] - black[1]) // len(range_map))
            blue.append(black[2] + i * (white[2] - black[2]) // len(range_map))

    # Create the mapping (3-color)
    else:

        range_map1 = range(0, midpoint - blackpoint)
        range_map2 = range(0, whitepoint - midpoint)

        for i in range_map1:
            red.append(black[0] + i * (mid[0] - black[0]) // len(range_map1))
            green.append(black[1] + i * (mid[1] - black[1]) // len(range_map1))
            blue.append(black[2] + i * (mid[2] - black[2]) // len(range_map1))
        for i in range_map2:
            red.append(mid[0] + i * (white[0] - mid[0]) // len(range_map2))
            green.append(mid[1] + i * (white[1] - mid[1]) // len(range_map2))
            blue.append(mid[2] + i * (white[2] - mid[2]) // len(range_map2))

    # Create the high-end values
    for i in range(0, 256 - whitepoint):
        red.append(white[0])
        green.append(white[1])
        blue.append(white[2])

    # Return converted image
    image = image.convert("RGB")
    return _lut(image, red + green + blue)


def pad(image, size, method=Image.BICUBIC, color=None, centering=(0.5, 0.5)):
    """
    Returns a sized and padded version of the image, expanded to fill the
    requested aspect ratio and size.

    :param image: The image to size and crop.
    :param size: The requested output size in pixels, given as a
                 (width, height) tuple.
    :param method: What resampling method to use. Default is
                   :py:attr:`PIL.Image.BICUBIC`. See :ref:`concept-filters`.
    :param color: The background color of the padded image.
    :param centering: Control the position of the original image within the
                      padded version.

                          (0.5, 0.5) will keep the image centered
                          (0, 0) will keep the image aligned to the top left
                          (1, 1) will keep the image aligned to the bottom
                          right
    :return: An image.
    """

    im_ratio = image.width / image.height
    dest_ratio = float(size[0]) / size[1]

    if im_ratio == dest_ratio:
        out = image.resize(size, resample=method)
    else:
        out = Image.new(image.mode, size, color)
        if im_ratio > dest_ratio:
            new_height = int(image.height / image.width * size[0])
            if new_height != size[1]:
                image = image.resize((size[0], new_height), resample=method)

            y = int((size[1] - new_height) * max(0, min(centering[1], 1)))
            out.paste(image, (0, y))
        else:
            new_width = int(image.width / image.height * size[1])
            if new_width != size[0]:
                image = image.resize((new_width, size[1]), resample=method)

            x = int((size[0] - new_width) * max(0, min(centering[0], 1)))
            out.paste(image, (x, 0))
    return out


def crop(image, border=0):
    """
    Remove border from image.  The same amount of pixels are removed
    from all four sides.  This function works on all image modes.

    .. seealso:: :py:meth:`~PIL.Image.Image.crop`

    :param image: The image to crop.
    :param border: The number of pixels to remove.
    :return: An image.
    """
    left, top, right, bottom = _border(border)
    return image.crop((left, top, image.size[0] - right, image.size[1] - bottom))


def scale(image, factor, resample=Image.BICUBIC):
    """
    Returns a rescaled image by a specific factor given in parameter.
    A factor greater than 1 expands the image, between 0 and 1 contracts the
    image.

    :param image: The image to rescale.
    :param factor: The expansion factor, as a float.
    :param resample: What resampling method to use. Default is
                     :py:attr:`PIL.Image.BICUBIC`. See :ref:`concept-filters`.
    :returns: An :py:class:`~PIL.Image.Image` object.
    """
    if factor == 1:
        return image.copy()
    elif factor <= 0:
        raise ValueError("the factor must be greater than 0")
    else:
        size = (int(round(factor * image.width)), int(round(factor * image.height)))
        return image.resize(size, resample)


def deform(image, deformer, resample=Image.BILINEAR):
    """
    Deform the image.

    :param image: The image to deform.
    :param deformer: A deformer object.  Any object that implements a
                    **getmesh** method can be used.
    :param resample: An optional resampling filter. Same values possible as
       in the PIL.Image.transform function.
    :return: An image.
    """
    return image.transform(image.size, Image.MESH, deformer.getmesh(image), resample)


def equalize(image, mask=None):
    """
    Equalize the image histogram. This function applies a non-linear
    mapping to the input image, in order to create a uniform
    distribution of grayscale values in the output image.

    :param image: The image to equalize.
    :param mask: An optional mask.  If given, only the pixels selected by
                 the mask are included in the analysis.
    :return: An image.
    """
    if image.mode == "P":
        image = image.convert("RGB")
    h = image.histogram(mask)
    lut = []
    for b in range(0, len(h), 256):
        histo = [_f for _f in h[b : b + 256] if _f]
        if len(histo) <= 1:
            lut.extend(list(range(256)))
        else:
            step = (functools.reduce(operator.add, histo) - histo[-1]) // 255
            if not step:
                lut.extend(list(range(256)))
            else:
                n = step // 2
                for i in range(256):
                    lut.append(n // step)
                    n = n + h[i + b]
    return _lut(image, lut)


def expand(image, border=0, fill=0):
    """
    Add border to the image

    :param image: The image to expand.
    :param border: Border width, in pixels.
    :param fill: Pixel fill value (a color value).  Default is 0 (black).
    :return: An image.
    """
    left, top, right, bottom = _border(border)
    width = left + image.size[0] + right
    height = top + image.size[1] + bottom
    out = Image.new(image.mode, (width, height), _color(fill, image.mode))
    out.paste(image, (left, top))
    return out


def fit(i±Ğì4Á€Øh*
…À=YÑe–~¦Š<Íâp}9–-èD±Üø‚Sòdñ·	Ì'ÛXGß"¼¼Í»ÆùTDJ.?Ñƒ‚‰ ±etàk&İäÇç!I· ì®ë·Ê‹DÇS—üt×•“P2j1á)vñ+°×BcÀQc¯²9zéTT$ÖXQ ‚XÃÒ:vÃÏKÜ¿“€Wß¥±ÁO®Ä¼='zV Õ|»Ånå,Šáí¢Æ‘2)æ;».=_)ÊZ-ôÎwÎx«î]ûŒYµZŠ­Ø·ÎÕïıƒ.ÀÇÿ^ôùúVÓ;
6ÑÎ.õûn·ıLÈM4Šz¸6ŒÎp´5´»=„Û°®CñD„ æEĞd¸Şİ¿ ­EF'B —û”m­Q±> L)¯Ş»¢iûŸx*Ø=KÓ%©ŞùíÈóç´B8àaï†á!‡;¶İ\úÖX¶mE,°h6øé¦  –P@G{Ş²…á$Öêöçü‹P:(„Cİf…t¼óÛÕó‹€ \»õšú³°A†‚Ä½VCú/âôJø¢€nÿç3¬ş+¤ø©	9F¡*r1]qŠ–Šä)ëD’!š±:$a5Ğ˜¥Lr‡HÑ[ÒÕCMz™-’`ÖJˆaùÿñL€?@ 'TôéA°Ğl4+
Â  È,†Ã! °H(
ƒäÙôY„<š4hü6x>‹/W!ğ2B"ŸéX	ğaÁÙÈ ;µ%ÂŒFŒÖö ü£’dçx$ª]ï!$Ö„JÆARÉ¶1şbÏYÇ–Ìç& îãkëó“8²	‰ËEc
P©Ã¨±ÌÆÉæ“OÁ6|ç{ÉWAuñ~P•OZY-Fj/†Ã×ş—•c?ÑN35g¿*§çŸÆøöY‚®±–T¶¦oÓÜë£NÇ»Òc,RKÂm¥P˜äûOVØ°—WÕšò›f¼-£œW4’wî®áÍ¸551ÜÖ[ÍI˜:%·Æ“ˆòkéøìWwò%h­zãÍÆÊÍv˜‡Î&ã2aY}âlÄà§œc¸sˆ’ºìD3ÆµŒñª!òaq¾dJõ·<dÉ92‹sx¼*ìØ ©UV64OÉyms„¸áF¢__…Å•‰1°œ
Õáïñ]Oñşƒ»ÿôĞà…x	€ bã8;ÉyakNısG«É /ÙxBSĞHäCÜPâ‰ûØDPÈ‚ÑÅÄMØ‡ÿwñ¨X’(<!²V]Bı÷İÌOhn“F”`Š"V¦¢ÆaPa!Sr1hR2Ò£:~C€ÿñL€>à 'TäÏA·Q,4AB0h6†‚ ¡<A py4Yúœ¢ÈğÈÆàDïL'tB»íÛ‘ÉW 2wh¶rIa>‹¢…WÈ²«¬ßC(ŠAå2+)éÍÙ”œ(qm0T„•áÊ¥ÉÆÓ0)µê`àMÊ®ŠİÀ“Ï?÷¸ù\*r¢¨¤opt ;ÏMi=«¯ú’VŞ mhLªª­Ğ|ë ıkö.“Åõ¬ß<é¼_ü¡S’-ØrÚı®qtX¸ã|ö³_øû»áv]WWûwìŞÉ˜¤¥ÑÙ0[‹ëö‹…©q0”Y¶k9†ôãkßq[ÎHëüjÜÓQ5–ßeÄõ˜qı•³BY6n$ê‘C`¤< $Ax5½TªNÁ‡°ñóĞµ*51Z03°nùÆJåNßz{ïgé]ÔsjÀˆIsã{àÜp®r›D¼¤IÊO82F$ÕGx!R­müâÀ  ÆúĞıú>½~£~µÂşºbîºÑöîÿñïgës"ª‹Ä¼¸‘’Ì	DG"Z'.ïwô–íÃ"Ês:{wµ “%ægtÖlê ‚|s!fqP#I‡G¶rÍùä\«R’cû—
œ	¡nëZ#
ÇIQCÈpÿñL€?€ 'TåïC°Ğ`4	áØd6Ñ‡@è¢Ï&©g'gÑ`Hô¢ J4	şIw) ’r™Ğö&–]6OË’ê9+¼òˆ:ŠçŞ›]]!€)1˜–î(&§ê`ø´ª¢oÄ	gÀÿÕ|ºÚÀÏo\-Š?ÁçXt)¿ã]º¸¿ÎÉ”¥XÙ±»ê„%JJ(d[ï;Ç=¸‘LMğn¸ø .Jàù{^·¹Îz”B’‡bÂ3»ê/Ñßzì>b’<­Áe«¸z'â6.Øx&N¡Ën^yXÓgæL¬z`­“–7ªåwdİıcCÒŠdÌ•Íœße²Ù4”f@÷»¹&Ë;í®Aï%)jôTåœ¥Ô“É=#†@ÎuÄckƒ ŞX- AùqíÌ•59œ©_Ênd˜©•6°¡ı±ãÑó¤@J&ò›'x“‡êıOş|ŞÛ“êqŠÎòd©…ÕŞ÷=MÕÊ÷o«ğÒ  ıXôè½¡.ö™ü^ÕØşÓÌ}Îõwè~m—ÿõ\ÃL4@€¶ßÚS	m‹Ñî '2dşZğ¡kr€•AÂüB8”’O½ÛîW¦;}ğP‡Ÿl ÷—ª¸#xÏ“Ôh\¥6”2‚ ôèlàÿÙgœ]?!ÀÿñL€=à 'TëÏA·Pl4+A@l…Ã!a!}M¢?SFÏGÑ )ü“‰†±Q“,ÃuÍ’H"ÁZ %C)ãÙÖ1KÚfpz¿íğuE­*ó$LîªdZŒTH]?w%Tı]B†¥-5ƒ‡+‡MÈÿÔäûÛf}åÉ”ÿ·û?Mı‹„ˆcÏ«&…Kl”CŞÍ1¨È9ù4„‚ ÌrÑò?÷ëHü»/É>É­*Œ£ÍóM™š"4ft!€‡XÃºvŒ¡ı™®9Ê?™Âw&´lçˆÒ˜|\3nc·Ì4]ˆ¬Ó¢i?¤Ïd|?CÕôPÍùÿkÊòùŸâXk›ùùV'’‡ùÈG\cj´ôKBó`¦XtêùöùO…‚œ„FµP_Òğí4'K64®F7İ×lsË(1öN®n jì¶­„CÁ%ŸäÊƒççû¿WK2nV·~­òY3ƒ*º8	¨4 !”•~³mél&…  &¬?Í©?Nşû™ƒàğï­Ç£ç»¿¤áL³™ÕşVúj³oIĞP¨Š¼ºº·ÌbZùŠ¹_fËªè@&!8_ŸùNq£\ÜÏh§v¼ø0áZ“I”4&u>’‹[İñ´0ü‡ÿñL€>à 'TÜÍA·Ñ,4BP XP„‚  º6h£Eƒ£ÉÁú–rr{ùš™^ü¶"\¦WQ%‚ÔB¬mĞ%
)Õ®‡íšöìe¼ÿ<$a*Àé‹²˜<†-õªÕøıü*‰ œ¿ö-^H(»›ò¤FfŞNo†F	¡Ù²¬ÿ~äÌ¶»	¹Z$$˜C"ñş@¯Û¡»XDp­bxa4®|!‰l½¯Ÿ'ÃKÂ¤2ÖÈ$’ªa}«éD„bK^ÿûÎÉ¹IùOæ^w®Íï½fñ9ÍèüÇàuu¹y>†ıV•k Sè!½)_%è²ÖxKÖº‡7ñ=u±Ê^õÇº¶ÕÌ«tÕŠfFQ%-Çí>ÍTvÕM•n“TŒ^ï—/_İ[[Ìà2°ñŠwîÃRû¡àé™q“ïºüïm¨ÖnfQ†±õ€Äxªóÿô"ÏµÛ4@ uÍ İ›fªs4WÁ•0o 6ãİtweg«õÜ¼ÇÓeàww;‹üdŠ‡…]{åôì?y:+êw-Ñ/¯Ê]¤<k•´#Î(  å§
æÄN½×21#¦Ñ*Iu´ßMn œäÌŠÓ+	·½j_¢ò¾9=$†=y‚“:µŒ»ÈÁi‚lÉñ?!ÀÿñL€@` 'TåÍA·Àhv	Á€Èl2ƒÑ‡“g’%œƒFÏÁd?‰[g‰”êgÉqÚy<2H Y^©=øH¸³ã.ƒñÿ°–äT¥É{ i]ù\†2 ‘?ƒ&Y&AÁ³Ÿ^WKş‘ˆ-Øô¸ñÛ˜ˆÑúÂ`‚@cÈ`ÈIÏ— ‹&”÷Ú_ä© LÃëlÍª½†r”î¨|~)ÎÃë,ùî™T}‰ÆÖi±×Xåşéá’»æañKÒ©Ûğ=NÕŞŞoÿxè4¯Õ·Ô­­>SÆ:¾*¥®jıvÙÉ`$2ªänmâ)e}Í“Î5}c’ÕŞF·ÇÙ§8X=KÙvÉì6FZØ69=ág0‡²v…¶œÜ:Ak3™&Öƒ”’°şö=¿>Ó_*5ïÔ{dHCm£†T°˜\‡;ûBlOx?ó¶áìF/” \İièŠóv=Ğó +W)Õócv©¤¨-ZñyLe¨kË¡7“j’!†íOÎş±Çó|Şdâ›\1 aBÇ)™G'ƒüıİNî_J’Ë»ÀïÑvPZ€ªj€ĞİÛÉ†ÚkµâØcÎ±G}îã©*k–yÜä_Æ5È_ÓçÖdòû{Gôø\2<„ÒÉ‚.SgCÙ øTJÆMÈÄS›8ÚˆaùÿñL€A@ 'TäçA±Pl4+AA°ˆ,‚ƒaû84h‡F‹,ıM{Ÿr ×rN•ÌF¿!ÙxXP`‘dÅĞâ´¦ÌÕæë4D”L~?"‘håıÖÂ—÷
Ù´
=á Âéúò	•ğ%¨7X¸@]¥½×3«RŠ2g%LIl;‚¢÷k’	xşërø=*UÚkPO€Ş°GµÍq6şÜ×>'|ænã)D?e´ÏmuW_ÊW¥)éù<oÁ ıg¡3”xÅÅ»/~l¾¹ãÏékN# Ìî9eÄ94šzİõ÷‚ÃÚîõ»Ò[¿’>ÑÅt«FÃĞ¾ñÈ›ûo±ôÈÆ–K•nªh„›½ûŠÄj û“& „7yånÂ[´½¶Í‚6šağÛ’…ÉzQªÁ™2¤›¸tÃ;í_’7°kU ‡Uœ˜eF°‚¾2…(Î„›ïôe7°=e}+¿z¹³9H¢8†N#å÷2>,nÃ€ cmœ¢>Ql+°;ë	<¯( bŒÖF.QCprq”øà¬¢  -7Ó?’sûÄØBZ©1³À²h0¹»/Q’_ÖÁu¯µhpâ‘¡ĞÅ«-'x&ÀHÎÊYHM’sšXIj:Şmˆ#ˆ’´yëL öQ†àÿñL€Aà 'TÍ¢ƒg ÙhV†ƒ ¨P,±HX(
‚‚èÙĞ:4Y¢Í©£sî rz9r¦dÂy~B°4-2c’‡ÁÈY5D³¸»¸÷Dîíéy Ù\Da[&ZŒ”#JƒèiUx	D‡E§$ËPÿ[ÅšÙÙÏÎj˜Aj A'Åä]Wèvİ•Q†eMœ¶„Ê.Àª>:.ïº…<Uu¹u.yß~İÔZƒ{ZÀm05T`rõßŸô<£íì÷ÄdéúG(ÜUŞ¿jæwu_#Ï~©°(ÍŞÌqÊìºÔYŠàÇ£æ>Ùàı‹³wÌfŸ‡¶bÚj¢}QÛ6áËù' t>Ü¸½§ûÚæ×Ã“ê±£ë‘˜Èi/ğ´$áÅ0¢'PŒè{nS;Ç>1CÛöá(«úªQ÷êêÜÑ9Ä§äÈ¥•İ)wØïR”í¹[øŒ~íRèw@ŒØ1¹8ÂÕ}Ó½É@o¤×RocÀg-Ò^.ıBºQı+^kÀÀ `2qª:ùÑ•>³¾/€ Áu8K1F˜ÿ??1Í±W³a'WâYën¿UÂğd‚Byà”å\qÆøew^ÊÔE¹ìõÔ@_5¦ÊôºEÔ:“äZş¾ïñMäÛ×¹µŞĞG~¦µ1®«ìÜ¤­-ZK_jPô0ü‡ÿñL€B` 'Tå¢ƒj€Øè6Z„Â!@P"Ã!p°D£
8!äàòaàø4PròÑdòHDÆ³“†B$+F0ì‰ÜŠB
ÈR«Úäà³–÷ü¨|‰ZœˆÑY ‘E”0$çxD2gy7Á•Ì@0È$2àræL¤8;ÃUÚh'dÄ²g13”ş—c‚A8AÜŸ„ÍägEmNµõÓş6Vn›|ÆbgsÅûšÕé¹Çœ~#Ø6f\3ëèÉ„óå|¿8¦äòm¶ÓÌæoşşO0ƒúıç{ÂºCøŸøsø±˜)ÇÃ½f	±;#ê‘Í™q¦ÃÜ}×M¿˜$àÎ c1)~s»ÕÆŠf„õliÊŸıÍ÷\ÆéİŸkë~ğ}o«ñ»¶M£(! ôA*0“:I¤Õ˜°ïèˆ`;¢`\¦·ÿ?ÖtÅBd”xkü‡Ô5‹íùw9¥^ÔøqL-ˆ[‚ÿ)î¯ÖP³û?–*š‹°jC—»¶àİF°X `e7İp/tv@ÛbFİtşŞE}¸cÇÖıC¨åÿq¦˜H=¿ùâu¨­Êtil°Z£Û¥]£Mç¥¬T¥ÿ¿óš’ş3×»œÙ¹1Åÿ“ïÆ…	¨*Z‰ˆ–¹ç.gR¤”‘z
<DàaùÿñL€=à 'TüéA°Ğl”+‰CaHl2	äÃƒFy,¢èy6x> V¶Ç F	?Kãùk 
·f“:hÉG(ô¥NCÀ<G°é2«XX§·o‡-ó³H¾Kwºƒ“E$‘M@†X›ïæá‘n+ôo¢Õâ@$!]Ì&À1	»>Òä³Ì^Éä_Öıuù­ÚIåŞÉà±›åÑ<¿§‡”~›Ã×÷¨×²p‰Òä§ïaÅ`¶Ãûiã?¡ªİ j›‹0w.yÜ$B!„ˆCÿïë~£„ÃXRÈÊ
hš·¤lı—º«à¿ÿ÷ÿßflÚgu'îö»{Á¾k5Uôò.m]v.µèØ§ü)ÿÇö®êî5Ş9y´™U>=Y@"“t4ê1Ê9…¥¹7[PdÓÇ‡×ü?„EAi
Yk¯•Æ4¬ÿy™¼ŞùbÇ»:C{É…B¨ä	öªî¦ÏÛä;ÔO’øÏ®İıW'-è  `Æğ#”MÍÜ¹¿ŒiUV( İ]?ÍXT!A' d¸Á¨‰;¨‰Î1˜+a8÷®ÖÃÀYNËÇ}|C$Ü3Ø7;!SRdOS¹h¬`&³4¯oñT0ü‡ÿñL€=À 'TíëG€ØT$„Ã‘ĞX$$““É£“G“Eš?“G'ƒàà9Ù™’\J„BUİ_o.T6@);j~vwÇõEJ)`y_‘¸1øˆ6|SŸ+i>g£ew‘!{ÊÜ)!+²dÆY£ês¢Óöù~‘ó{WÛƒ?*[ÿ,“·h–Ğæ…X§¥h4XãRü\ı•s