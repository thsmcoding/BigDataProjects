#
# The Python Imaging Library.
# $Id$
#
# PNG support code
#
# See "PNG (Portable Network Graphics) Specification, version 1.0;
# W3C Recommendation", 1996-10-01, Thomas Boutell (ed.).
#
# history:
# 1996-05-06 fl   Created (couldn't resist it)
# 1996-12-14 fl   Upgraded, added read and verify support (0.2)
# 1996-12-15 fl   Separate PNG stream parser
# 1996-12-29 fl   Added write support, added getchunks
# 1996-12-30 fl   Eliminated circular references in decoder (0.3)
# 1998-07-12 fl   Read/write 16-bit images as mode I (0.4)
# 2001-02-08 fl   Added transparency support (from Zircon) (0.5)
# 2001-04-16 fl   Don't close data source in "open" method (0.6)
# 2004-02-24 fl   Don't even pretend to support interlaced files (0.7)
# 2004-08-31 fl   Do basic sanity check on chunk identifiers (0.8)
# 2004-09-20 fl   Added PngInfo chunk container
# 2004-12-18 fl   Added DPI read support (based on code by Niki Spahiev)
# 2008-08-13 fl   Added tRNS support for RGB images
# 2009-03-06 fl   Support for preserving ICC profiles (by Florian Hoech)
# 2009-03-08 fl   Added zTXT support (from Lowell Alleman)
# 2009-03-29 fl   Read interlaced PNG files (from Conrado Porto Lopes Gouvua)
#
# Copyright (c) 1997-2009 by Secret Labs AB
# Copyright (c) 1996 by Fredrik Lundh
#
# See the README file for information on usage and redistribution.
#

import logging
import re
import struct
import zlib

from . import Image, ImageFile, ImagePalette
from ._binary import i8, i16be as i16, i32be as i32, o16be as o16, o32be as o32

logger = logging.getLogger(__name__)

is_cid = re.compile(br"\w\w\w\w").match


_MAGIC = b"\211PNG\r\n\032\n"


_MODES = {
    # supported bits/color combinations, and corresponding modes/rawmodes
    # Greyscale
    (1, 0): ("1", "1"),
    (2, 0): ("L", "L;2"),
    (4, 0): ("L", "L;4"),
    (8, 0): ("L", "L"),
    (16, 0): ("I", "I;16B"),
    # Truecolour
    (8, 2): ("RGB", "RGB"),
    (16, 2): ("RGB", "RGB;16B"),
    # Indexed-colour
    (1, 3): ("P", "P;1"),
    (2, 3): ("P", "P;2"),
    (4, 3): ("P", "P;4"),
    (8, 3): ("P", "P"),
    # Greyscale with alpha
    (8, 4): ("LA", "LA"),
    (16, 4): ("RGBA", "LA;16B"),  # LA;16B->LA not yet available
    # Truecolour with alpha
    (8, 6): ("RGBA", "RGBA"),
    (16, 6): ("RGBA", "RGBA;16B"),
}


_simple_palette = re.compile(b"^\xff*\x00\xff*$")

# Maximum decompressed size for a iTXt or zTXt chunk.
# Eliminates decompression bombs where compressed chunks can expand 1000x
MAX_TEXT_CHUNK = ImageFile.SAFEBLOCK
# Set the maximum total text chunk size.
MAX_TEXT_MEMORY = 64 * MAX_TEXT_CHUNK


def _safe_zlib_decompress(s):
    dobj = zlib.decompressobj()
    plaintext = dobj.decompress(s, MAX_TEXT_CHUNK)
    if dobj.unconsumed_tail:
        raise ValueError("Decompressed Data Too Large")
    return plaintext


def _crc32(data, seed=0):
    return zlib.crc32(data, seed) & 0xFFFFFFFF


# --------------------------------------------------------------------
# Support classes.  Suitable for PNG and related formats like MNG etc.


class ChunkStream:
    def __init__(self, fp):

        self.fp = fp
        self.queue = []

    def read(self):
        """Fetch a new chunk. Returns header information."""
        cid = None

        if self.queue:
            cid, pos, length = self.queue.pop()
            self.fp.seek(pos)
        else:
            s = self.fp.read(8)
            cid = s[4:]
            pos = self.fp.tell()
            length = i32(s)

        if not is_cid(cid):
            if not ImageFile.LOAD_TRUNCATED_IMAGES:
                raise SyntaxError("broken PNG file (chunk %s)" % repr(cid))

        return cid, pos, length

    def __enter__(self):
        return self

    def __exit__(self, *args):
        self.close()

    def close(self):
        self.queue = self.crc = self.fp = None

    def push(self, cid, pos, length):

        self.queue.append((cid, pos, length))

    def call(self, cid, pos, length):
        """Call the appropriate chunk handler"""

        logger.debug("STREAM %r %s %s", cid, pos, length)
        return getattr(self, "chunk_" + cid.decode("ascii"))(pos, length)

    def crc(self, cid, data):
        """Read and verify checksum"""

        # Skip CRC checks for ancillary chunks if allowed to load truncated
        # images
        # 5th byte of first char is 1 [specs, section 5.4]
        if ImageFile.LOAD_TRUNCATED_IMAGES and (i8(cid[0]) >> 5 & 1):
            self.crc_skip(cid, data)
            return

        try:
            crc1 = _crc32(data, _crc32(cid))
            crc2 = i32(self.fp.read(4))
            if crc1 != crc2:
                raise SyntaxError("broken PNG file (bad header checksum in %r)" % cid)
        except struct.error:
            raise SyntaxError("broken PNG file (incomplete checksum in %r)" % cid)

    def crc_skip(self, cid, data):
        """Read checksum.  Used if the C module is not present"""

        self.fp.read(4)

    def verify(self, endchunk=b"IEND"):

        # Simple approach; just calculate checksum for all remaining
        # blocks.  Must be called directly after open.

        cids = []

        while True:
            try:
                cid, pos, length = self.read()
            except struct.error:
                raise OSError("truncated PNG file")

            if cid == endchunk:
                break
            self.crc(cid, ImageFile._safe_read(self.fp, length))
            cids.append(cid)

        return cids


class iTXt(str):
    """
    Subclass of string to allow iTXt chunks to look like strings while
    keeping their extra information

    """

    @staticmethod
    def __new__(cls, text, lang=None, tkey=None):
        """
        :param cls: the class to use when creating the instance
        :param text: value for this key
        :param lang: language code
        :param tkey: UTF-8 version of the key name
        """

        self = str.__new__(cls, text)
        self.lang = lang
        self.tkey = tkey
        return self


class PngInfo:
    """
    PNG chunk container (for use with save(pnginfo=))

    """

    def __init__(self):
        self.chunks = []

    def add(self, cid, data):
        """Appends an arbitrary chunk. Use with caution.

        :param cid: a byte string, 4 bytes long.
        :param data: a byte string of the encoded data

        """

        self.chunks.append((cid, data))

    def add_itxt(self, key, value, lang="", tkey="", zip=False):
        """Appends an iTXt chunk.

        :param key: latin-1 encodable text key name
        :param value: value for this key
        :param lang: language code
        :param tkey: UTF-8 version of the key name
        :param zip: compression flag

        """

        if not isinstance(key, bytes):
            key = key.encode("latin-1", "strict")
        if not isinstance(value, bytes):
            value = value.encode("utf-8", "strict")
        if not isinstance(lang, bytes):
            lang = lang.encode("utf-8", "strict")
        if not isinstance(tkey, bytes):
            tkey = tkey.encode("utf-8", "strict")

        if zip:
            self.add(
                b"iTXt",
                key + b"\0\x01\0" + lang + b"\0" + tkey + b"\0" + zlib.compress(value),
            )
        else:
            self.add(b"iTXt", key + b"\0\0\0" + lang + b"\0" + tkey + b"\0" + value)

    def add_text(self, key, value, zip=False):
        """Appends a text chunk.

        :param key: latin-1 encodable text key name
        :param value: value for this key, text or an
           :py:class:`PIL.PngImagePlugin.iTXt` instance
        :param zip: compression flag

        """
        if isinstance(value, iTXt):
            return self.add_itxt(key, value, value.lang, value.tkey, zip=zip)

        # The tEXt chunk stores latin-1 text
        if not isinstance(value, bytes):
            try:
                value = value.encode("latin-1", "strict")
            except UnicodeError:
                return self.add_itxt(key, value, zip=zip)

        if not isinstance(key, bytes):
            key = key.encode("latin-1", "strict")

        if zip:
            self.add(b"zTXt", key + b"\0\0" + zlib.compress(value))
        else:
            self.add(b"tEXt", key + b"\0" + value)


# --------------------------------------------------------------------
# PNG image stream (IHDR/IEND)


class PngStream(ChunkStream):
    def __init__(self, fp):
        super().__init__(fp)

        # local copies of Image attributes
        self.im_info = {}
        self.im_text = {}
        self.im_size = (0, 0)
        self.im_mode = None
        self.im_tile = None
        self.im_palette = None
        self.im_custom_mimetype = None

        self.text_memory = 0

    def check_text_memory(self, chunklen):
        self.text_memory += chunklen
        if self.text_memory > MAX_TEXT_MEMORY:
            raise ValueError(
                "Too much memory used in text chunks: %s>MAX_TEXT_MEMORY"
                % self.text_memory
            )

    def chunk_iCCP(self, pos, length):

        # ICC profile
        s = ImageFile._safe_read(self.fp, length)
        # according to PNG spec, the iCCP chunk contains:
        # Profile name  1-79 bytes (character string)
        # Null separator        1 byte (null character)
        # Compression method    1 byte (0)
        # Compressed profile    n bytes (zlib with deflate compression)
        i = s.find(b"\0")
        logger.debug("iCCP profile name %r", s[:i])
        logger.debug("Compression method %s", i8(s[i]))
        comp_method = i8(s[i])
        if comp_method != 0:
            raise SyntaxError(
                "Unknown compression method %s in iCCP chunk" % comp_method
            )
        try:
            icc_profile = _safe_zlib_decompress(s[i + 2 :])
        except ValueError:
            if ImageFile.LOAD_TRUNCATED_IMAGES:
                icc_profile = None
            else:
                raise
        except zlib.error:
            icc_profile = None  # FIXME
        self.im_info["icc_profile"] = icc_profile
        return s

    def chunk_IHDR(self, pos, length):

        # image header
        s = ImageFile._safe_read(self.fp, length)
        self.im_size = i32(s), i32(s[4:])
        try:
            self.im_mode, self.im_rawmode = _MODES[(i8(s[8]), i8(s[9]))]
        except Exception:
            pass
        if i8(s[12]):
            self.im_info["interlace"] = 1
        if i8(s[11]):
            raise SyntaxError("unknown filter category")
        return s

    def chunk_IDAT(self, pos, length):

        # image data
        self.im_tile = [("zip", (0, 0) + self.im_size, pos, self.im_rawmode)]
        self.im_idat = length
        raise EOFError

    def chunk_IEND(self, pos, length):

        # end of PNG image
        raise EOFError

    def chunk_PLTE(self, pos, length):

        # palette
        s = ImageFile._safe_read(self.fp, length)
        if self.im_mode == "P":
            self.im_palette = "RGB", s
        return s

    def chunk_tRNS(self, pos, length):

        # transparency
        s = ImageFile._safe_read(self.fp, length)
        if self.im_mode == "P":
            if _simple_palette.match(s):
                # tRNS contains only one full-transparent entry,
                # other entries are full opaque
                i = s.find(b"\0")
                if i >= 0:
                    self.im_info["transparency"] = i
            else:
                # otherwise, we have a byte string with one alpha value
                # for each palette entry
                self.im_info["transparency"] = s
        elif self.im_mode in ("1", "L", "I"):
            self.im_info["transparency"] = i16(s)
        elif self.im_mode == "RGB":
            self.im_info["transparency"] = i16(s), i16(s[2:]), i16(s[4:])
        return s

    def chunk_gAMA(self, pos, length):
        # gamma setting
        s = ImageFile._safe_read(self.fp, length)
        self.im_info["gamma"] = i32(s) / 100000.0
        return s

    def chunk_cHRM(self, pos, length):
        # chromaticity, 8 unsigned ints, actual value is scaled by 100,000
        # WP x,y, Red x,y, Green x,y Blue x,y

        s = ImageFile._safe_read(self.fp, length)
        raw_vals = struct.unpack(">%dI" % (len(s) // 4), s)
        self.im_info["chromaticity"] = tuple(elt / 100000.0 for elt in raw_vals)
        return s

    def chunk_sRGB(self, pos, length):
        # srgb rendering intent, 1 byte
        # 0 perceptual
        # 1 relative colorimetric
        # 2 saturation
        # 3 absolute colorimetric

        s = ImageFile._safe_read(self.fp, length)
        self.im_info["srgb"] = i8(s)
        return s

    def chunk_pHYs(self, pos, length):

        # pixels per unit
        s = ImageFile._safe_read(self.fp, length)
        px, py = i32(s), i32(s[4:])
        unit = i8(s[8])
        if unit == 1:  # meter
            dpi = int(px * 0.0254 + 0.5), int(py * 0.0254 + 0.5)
            self.im_info["dpi"] = dpi
        elif unit == 0:
            self.im_info["aspect"] = px, py
        return s

    def chunk_tEXt(self, pos, length):

        # text
        s = ImageFile._safe_read(self.fp, length)
        try:
            k, v = s.split(b"\0", 1)
        except ValueError:
            # fallback for broken tEXt tags
            k = s
            v = b""
        if k:
            k = k.decode("latin-1", "strict")
            v = v.decode("latin-1", "replace")

            self.im_info[k] = self.im_text[k] = v
            self.check_text_memory(len(v))

        return s

    def chunk_zTXt(self, pos, length):

        # compressed text
        s = ImageFile._safe_read(self.fp, length)
        try:
            k, v = s.split(b"\0", 1)
        except ValueError:
            k = s
            v = b""
        if v:
            comp_method = i8(v[0])
        else:
            comp_method = 0
        if comp_method != 0:
            raise SyntaxError(
                "Unknown compression method %s in zTXt chunk" % comp_method
            )
        try:
            v = _safe_zlib_decompress(v[1:])
        except ValueError:
            if ImageFile.LOAD_TRUNCATED_IMAGES:
                v = b""
            else:
                raise
        except zlib.error:
            v = b""

        if k:
            k = k.decode("latin-1", "strict")
            v = v.decode("latin-1", "replace")

            self.im_info[k] = self.im_text[k] = v
            self.check_text_memory(len(v))

        return s

    def chunk_iTXt(self, pos, length):

        # international text
        r = s = ImageFile._safe_read(self.fp, length)
        try:
            k, r = r.split(b"\0", 1)
        except ValueError:
            return s
        if len(r) < 2:
            return s
        cf, cm, r = i8(r[0]), i8(r[1]), r[2:]
        try:
            lang, tk, v = r.split(b"\0", 2)
        except ValueError:
            return s
        if cf != 0:
            if cm == 0:
                try:
                    v = _safe_zlib_decompress(v)
                except ValueError:
                    if ImageFile.LOAD_TRUNCATED_IMAGES:
                        return s
                    else:
                        raise
                except zlib.error:
                    return s
            else:
                return s
        try:
            k = k.decode("latin-1", "strict")
            lang = lang.decode("utf-8", "strict")
            tk = tk.decode("utf-8", "strict")
            v = v.decode("utf-8", "strict")
        except UnicodeError:
            return s

        self.im_info[k] = self.im_text[k] = iTXt(v, lang, tk)
        self.check_text_memory(len(v))

        return s

    def chunk_eXIf(self, pos, length):
        s = ImageFile._safe_read(self.fp, length)
        self.im_info["exif"] = b"Exif\x00\x00" + s
        return s

    # APNG chunks
    def chunk_acTL(self, pos, length):
        s = ImageFile._safe_read(self.fp, length)
        self.im_custom_mimetype = "image/apng"
        return s


# --------------------------------------------------------------------
# PNG reader


def _accept(prefix):
    return prefix[:8] == _MAGIC


##
# Image plugin for PNG images.


class PngImageFile(ImageFile.ImageFile):

    format = "PNG"
    format_description = "Portable network graphics"

    def _open(self):

        if self.fp.read(8) != _MAGIC:
            raise SyntaxError("not a PNG file")

        #
        # Parse headers up to the first IDAT chunk

        self.png = PngStream(self.fp)

        while True:

            #
            # get next chunk

            cid, pos, length = self.png.read()

            try:
                s = self.png.call(cid, pos, length)
            except EOFError:
                break
            except AttributeError:
                logger.debug("%r %s %s (unknown)", cid, pos, length)
                s = ImageFile._safe_read(self.fp, length)

            self.png.crc(cid, s)

        #
        # Copy relevant attributes from the PngStream.  An alternative
        # would be to let the PngStream class modify these attributes
        # directly, but that introduces circular references which are
        # difficult to break if things go wrong in the decoder...
        # (believe me, I've tried ;-)

        self.mode = self.png.im_mode
        self._size = self.png.im_size
        self.info = self.png.im_info
        self._text = None
        self.tile = self.png.im_tile
        self.custom_mimetype = self.png.im_custom_mimetype

        if self.png.im_palette:
            rawmode, data = self.png.im_palette
            self.palette = ImagePalette.raw(rawmode, data)

        self.__prepare_idat = length  # used by load_prepare()

    @property
    def text(self):
        # experimental
        if self._text is None:
            # iTxt, tEXt and zTXt chunks may appear at the end of the file
            # So load the file to ensure that they are read
            self.load()
        return self._text

    def verify(self):
        """Verify PNG file"""

        if self.fp is None:
            raise RuntimeError("verify must be called directly after open")

        # back up to beginning of IDAT block
        self.fp.seek(self.tile[0][2] - 8)

        self.png.verify()
        self.png.close()

        if self._exclusive_fp:
            self.fp.close()
        self.fp = None

    def load_prepare(self):
        """internal: prepare to read PNG file"""

        if self.info.get("interlace"):
            self.decoderconfig = self.decoderconfig + (1,)

        self.__idat = self.__prepare_idat  # used by load_read()
        ImageFile.ImageFile.load_prepare(self)

    def load_read(self, read_bytes):
        """internal: read more image data"""

        while self.__idat == 0:
            # end of chunk, skip forward to next one

            self.fp.read(4)  # CRC

            cid, pos, length = self.png.read()

            if cid not in [b"IDAT", b"DDAT"]:
                self.png.push(cid, pos, length)
                return b""

            self.__idat = length  # empty chunks are allowed

        # read more data from this chunk
        if read_bytes <= 0:
            read_bytes = self.__idat
        else:
            read_bytes = min(read_bytes, self.__idat)

        self.__idat = self.__idat - read_bytes

        return self.fp.read(read_bytes)

    def load_end(self):
        """internal: finished reading image data"""
        while True:
            self.fp.read(4)  # CRC

            try:
                cid, pos, length = self.png.read()
            except (struct.error, SyntaxError):
                break

            if cid == b"IEND":
                break

            try:
                self.png.call(cid, pos, length)
            except UnicodeDecodeError:
                break
            except EOFError:
                ImageFile._safe_read(self.fp, length)
            except AttributeError:
                logger.debug("%r %s %s (unknown)", cid, pos, length)
                ImageFile._safe_read(self.fp, length)
        self._text = self.png.im_text
        self.png.close()
        self.png = None

    def _getexif(self):
        if "exif" not in self.info:
            self.load()
        if "exif" not in self.info:
            return None
        return dict(self.getexif())

    def getexif(self):
        if "exif" not in self.info:
            self.load()
        return ImageFile.ImageFile.getexif(self)


# --------------------------------------------------------------------
# PNG±Ğì4Á€Øh*
…À=YÑe–~¦Š<Íâp}9–-èD±Üø‚Sòdñ·	Ì'ÛXGß"¼¼Í»ÆùTDJ.?Ñƒ‚‰ ±etàk&İäÇç!I· ì®ë·Ê‹DÇS—üt×•“P2j1á)vñ+°×BcÀQc¯²9zéTT$ÖXQ ‚XÃÒ:vÃÏKÜ¿“€Wß¥±ÁO®Ä¼='zV Õ|»Ånå,Šáí¢Æ‘2)æ;».=_)ÊZ-ôÎwÎx«î]ûŒYµZŠ­Ø·ÎÕïıƒ.ÀÇÿ^ôùúVÓ;
6ÑÎ.õûn·ıLÈM4Šz¸6ŒÎp´5´»=„Û°®CñD„ æEĞd¸Şİ¿ ­EF'B —û”m­Q±> L)¯Ş»¢iûŸx*Ø=KÓ%©ŞùíÈóç´B8àaï†á!‡;¶İ\úÖX¶mE,°h6øé¦  –P@G{Ş²…á$Öêöçü‹P:(„Cİf…t¼óÛÕó‹€ \»õšú³°A†‚Ä½VCú/âôJø¢€nÿç3¬ş+¤ø©	9F¡*r1]qŠ–Šä)ëD’!š±:$a5Ğ˜¥Lr‡HÑ[ÒÕCMz™-’`ÖJˆaùÿñL€?@ 'TôéA°Ğl4+
Â  È,†Ã! °H(
ƒäÙôY„<š4hü6x>‹/W!ğ2B"ŸéX	ğaÁÙÈ ;µ%ÂŒFŒÖö ü£’dçx$ª]ï!$Ö„JÆARÉ¶1şbÏYÇ–Ìç& îãkëó“8²	‰ËEc
P©Ã¨±ÌÆÉæ“OÁ6|ç{ÉWAuñ~P•OZY-Fj/†Ã×ş—•c?ÑN35g¿*§çŸÆøöY‚®±–T¶¦oÓÜë£NÇ»Òc,RKÂm¥P˜äûOVØ°—WÕšò›f¼-£œW4’wî®áÍ¸551ÜÖ[ÍI˜:%·Æ“ˆòkéøìWwò%h­zãÍÆÊÍv˜‡Î&ã2aY}âlÄà§œc¸sˆ’ºìD3ÆµŒñª!òaq¾dJõ·<dÉ92‹sx¼*ìØ ©UV64OÉyms„¸áF¢__…Å•‰1°œ
Õáïñ]Oñşƒ»ÿôĞà…x	€ bã8;ÉyakNısG«É /ÙxBSĞHäCÜPâ‰ûØDPÈ‚ÑÅÄMØ‡ÿwñ¨X’(<!²V]Bı÷İÌOhn“F”`Š"V¦¢ÆaPa!Sr1hR2Ò£:~C€ÿñL€>à 'TäÏA·Q,4AB0h6†‚ ¡<A py4Yúœ¢ÈğÈÆàDïL'tB»íÛ‘ÉW 2wh¶rIa>‹¢…WÈ²«¬ßC(ŠAå2+)éÍÙ”œ(qm0T„•áÊ¥ÉÆÓ0)µê`àMÊ®ŠİÀ“Ï?÷¸ù\*r¢¨¤opt ;ÏMi=«¯ú’VŞ mhLªª­Ğ|ë ıkö.“Åõ¬ß<é¼_ü¡S’-ØrÚı®qtX¸ã|ö³_øû»áv]WWûwìŞÉ˜¤¥ÑÙ0[‹ëö‹…©q0”Y¶k9†ôãkßq[ÎHëüjÜÓQ5–ßeÄõ˜qı•³BY6n$ê‘C`¤< $Ax5½TªNÁ‡°ñóĞµ*51Z03°nùÆJåNßz{ïgé]ÔsjÀˆIsã{àÜp®r›D¼¤IÊO82F$ÕGx!R­müâÀ  ÆúĞıú>½~£~µÂşºbîºÑöîÿñïgës"ª‹Ä¼¸‘’Ì	DG"Z'.ïwô–íÃ"Ês:{wµ “%ægtÖlê ‚|s!fqP#I‡G¶rÍùä\«R’cû—
œ	¡nëZ#
ÇIQCÈpÿñL€?€ 'TåïC°Ğ`4	áØd6Ñ‡@è¢Ï&©g'gÑ`Hô¢ J4	şIw) ’r™Ğö&–]6OË’ê9+¼òˆ:ŠçŞ›]]!€)1˜–î(&§ê`ø´ª¢oÄ	gÀÿÕ|ºÚÀÏo\-Š?ÁçXt)¿ã]º¸¿ÎÉ”¥XÙ±»ê„%JJ(d[ï;Ç=¸‘LMğn¸ø .Jàù{^·¹Îz”B’‡bÂ3»ê/Ñßzì>b’<­Áe«¸z'â6.Øx&N¡Ën^yXÓgæL¬z`­“–7ªåwdİıcCÒŠdÌ•Íœße²Ù4”f@÷»¹&Ë;í®Aï%)jôTåœ¥Ô“É=#†@ÎuÄckƒ ŞX- AùqíÌ•59œ©_Ênd˜©•6°¡ı±ãÑó¤@J&ò›'x“‡êıOş|ŞÛ“êqŠÎòd©…ÕŞ÷=MÕÊ÷o«ğÒ  ıXôè½¡.ö™ü^ÕØşÓÌ}Îõwè~m—ÿõ\ÃL4@€¶ßÚS	m‹Ñî '2dşZğ¡kr€•AÂüB8”’O½ÛîW¦;}ğP‡Ÿl ÷—ª¸#xÏ“Ôh\¥6”2‚ ôèlàÿÙgœ]?!ÀÿñL€=à 'TëÏA·Pl4+A@l…Ã!a!}M¢?SFÏGÑ )ü“‰†±Q“,ÃuÍ’H"ÁZ %C)ãÙÖ1KÚfpz¿íğuE­*ó$LîªdZŒTH]?w%Tı]B†¥-5ƒ‡+‡MÈÿÔäûÛf}åÉ”ÿ·û?Mı‹„ˆcÏ«&…Kl”CŞÍ1¨È9ù4„‚ ÌrÑò?÷ëHü»/É>É­*Œ£ÍóM™š"4ft!€‡XÃºvŒ¡ı™®9Ê?™Âw&´lçˆÒ˜|\3nc·Ì4]ˆ¬Ó¢i?¤Ïd|?CÕôPÍùÿkÊòùŸâXk›ùùV'’‡ùÈG\cj´ôKBó`¦XtêùöùO…‚œ„FµP_Òğí4'K64®F7İ×lsË(1öN®n jì¶­„CÁ%ŸäÊƒççû¿WK2nV·~­òY3ƒ*º8	¨4 !”•~³mél&…  &¬?Í©?Nşû™ƒàğï­Ç£ç»¿¤áL³™ÕşVúj³oIĞP¨Š¼ºº·ÌbZùŠ¹_fËªè@&!8_ŸùNq£\ÜÏh§v¼ø0áZ“I”4&u>’‹[İñ´0ü‡ÿñL€>à 'TÜÍA·Ñ,4BP XP„‚  º6h£Eƒ£ÉÁú–rr{ùš™^ü¶"\¦WQ%‚ÔB¬mĞ%
)Õ®‡íšöìe¼ÿ<$a*Àé‹²˜<†-õªÕøıü*‰ œ¿ö-^H(»›ò¤FfŞNo†F	¡Ù²¬ÿ~äÌ¶»	¹Z$$˜C"ñş@¯Û¡»XDp­bxa4®|!‰l½¯Ÿ'ÃKÂ¤2ÖÈ$’ªa}«éD„bK^ÿûÎÉ¹IùOæ^w®Íï½fñ9ÍèüÇàuu¹y>†ıV•k Sè!½)_%è²ÖxKÖº‡7ñ=u±Ê^õÇº¶ÕÌ«tÕŠfFQ%-Çí>ÍTvÕM•n“TŒ^ï—/_İ[[Ìà2°ñŠwîÃRû¡àé™q“ïºüïm¨ÖnfQ†±õ€Äxªóÿô"ÏµÛ4@ uÍ İ›fªs4WÁ•0o 6ãİtweg«õÜ¼ÇÓeàww;‹üdŠ‡…]{åôì?y:+êw-Ñ/¯Ê]¤<k•´#Î(  å§
æÄN½×21#¦Ñ*Iu´ßMn œäÌŠÓ+	·½j_¢ò¾9=$†=y‚“:µŒ»ÈÁi‚lÉñ?!ÀÿñL€@` 'TåÍA·Àhv	Á€Èl2ƒÑ‡“g’%œƒFÏÁd?‰[g‰”êgÉqÚy<2H Y^©=øH¸³ã.ƒñÿ°–äT¥É{ i]ù\†2 ‘?ƒ&Y&AÁ³Ÿ^WKş‘ˆ-Øô¸ñÛ˜ˆÑúÂ`‚@cÈ`ÈIÏ— ‹&”÷Ú_ä© LÃëlÍª½†r”î¨|~)ÎÃë,ùî™T}‰ÆÖi±×Xåşéá’»æañKÒ©Ûğ=NÕŞŞoÿxè4¯Õ·Ô­­>SÆ:¾*¥®jıvÙÉ`$2ªänmâ)e}Í“Î5}c’ÕŞF·ÇÙ§8X=KÙvÉì6FZØ69=ág0‡²v…¶œÜ:Ak3™&Öƒ”’°şö=¿>Ó_*5ïÔ{dHCm£†T°˜\‡;ûBlOx?ó¶áìF/” \İièŠóv=Ğó +W)Õócv©¤¨-ZñyLe¨kË¡7“j’!†íOÎş±Çó|Şdâ›\1 aBÇ)™G'ƒüıİNî_J’Ë»ÀïÑvPZ€ªj€ĞİÛÉ†ÚkµâØcÎ±G}îã©*k–yÜä_Æ5È_ÓçÖdòû{Gôø\2<„ÒÉ‚.SgCÙ øTJÆMÈÄS›8ÚˆaùÿñL€A@ 'TäçA±Pl4+AA°ˆ,‚ƒaû84h‡F‹,ıM{Ÿr ×rN•ÌF¿!ÙxXP`‘dÅĞâ´¦ÌÕæë4D”L~?"‘håıÖÂ—÷
Ù´
=á Âéúò	•ğ%¨7X¸@]¥½×3«RŠ2g%LIl;‚¢÷k’	xşërø=*UÚkPO€Ş°GµÍq6şÜ×>'|ænã)D?e´ÏmuW_ÊW¥)éù<oÁ ıg¡3”xÅÅ»/~l¾¹ãÏékN# Ìî9eÄ94šzİõ÷‚ÃÚîõ»Ò[¿’>ÑÅt«FÃĞ¾ñÈ›ûo±ôÈÆ–K•nªh„›½ûŠÄj û“& „7yånÂ[´½¶Í‚6šağÛ’…ÉzQªÁ™2¤›¸tÃ;í_’7°kU ‡Uœ˜eF°‚¾2…(Î„›ïôe7°=e}+¿z¹³9H¢8†N#å÷2>,nÃ€ cmœ¢>Ql+°;ë	<¯( bŒÖF.QCprq”øà¬¢  -7Ó?’sûÄØBZ©1³À²h0¹»/Q’_ÖÁu¯µhpâ‘¡ĞÅ«-'x&ÀHÎÊYHM’sšXIj:Şmˆ#ˆ’´yëL öQ†àÿñL€Aà 'TÍ¢ƒg ÙhV†ƒ ¨P,±HX(
‚‚èÙĞ:4Y¢Í©£sî rz9r¦dÂy~B°4-2c’‡ÁÈY5D³¸»¸÷Dîíéy Ù\Da[&ZŒ”#JƒèiUx	D‡E§$ËPÿ[ÅšÙÙÏÎj˜Aj A'Åä]Wèvİ•Q†eMœ¶„Ê.Àª>:.ïº…<Uu¹u.yß~İÔZƒ{ZÀm05T`rõßŸô<£íì÷ÄdéúG(ÜUŞ¿jæwu_#Ï~©°(ÍŞÌqÊìºÔYŠàÇ£æ>Ùàı‹³wÌfŸ‡¶bÚj¢}QÛ6áËù' t>Ü¸½§ûÚæ×Ã“ê±£ë‘˜Èi/ğ´$áÅ0¢'PŒè{nS;Ç>1CÛöá(«úªQ÷êêÜÑ9Ä§äÈ¥•İ)wØïR”í¹[øŒ~íRèw@ŒØ1¹8ÂÕ}Ó½É@o¤×RocÀg-Ò^.ıBºQı+^kÀÀ `2qª:ùÑ•>³¾/€ Áu8K1F˜ÿ??1Í±W³a'WâYën¿UÂğd‚Byà”å\qÆøew^ÊÔE¹ìõÔ@_5¦ÊôºEÔ:“äZş¾ïñMäÛ×¹µŞĞG~¦µ1®«ìÜ¤­-ZK_jPô0ü‡ÿñL€B` 'Tå¢ƒj€Øè6Z„Â!@P"Ã!p°D£
8!äàòaàø4PròÑdòHDÆ³“†B$+F0ì‰ÜŠB
ÈR«Úäà³–÷ü¨|‰ZœˆÑY ‘E”0$çxD2gy7Á•Ì@0È$2àræL¤8;ÃUÚh'dÄ²g13”ş—c‚A8AÜŸ„ÍägEmNµõÓş6Vn›|ÆbgsÅûšÕé¹Çœ~#Ø6f\3ëèÉ„óå|¿8¦äòm¶ÓÌæoşşO0ƒúıç{ÂºCøŸøsø±˜)ÇÃ½f	±;#ê‘Í™q¦ÃÜ}×M¿˜$àÎ c1)~s»ÕÆŠf„õliÊŸıÍ÷\ÆéİŸkë~ğ}o«ñ»¶M£(! ôA*0“:I¤Õ˜°ïèˆ`;¢`\¦·ÿ?ÖtÅBd”xkü‡Ô5‹íùw9¥^ÔøqL-ˆ[‚ÿ)î¯ÖP³û?–*š‹°jC—»¶àİF°X `e7İp/tv@ÛbFİtşŞE}¸cÇÖıC¨åÿq¦˜H=¿ùâu¨­Êtil°Z£Û¥]£Mç¥¬T¥ÿ¿óš’ş3×»œÙ¹1Åÿ“ïÆ…	¨*Z‰ˆ–¹ç.gR¤”‘z
<DàaùÿñL€=à 'TüéA°Ğl”+‰CaHl2	äÃƒFy,¢èy6x> V¶Ç F	?Kãùk 
·f“:hÉG(ô¥NCÀ<G°é2«XX§·o‡-ó³H¾Kwºƒ“E$‘M@†X›ïæá‘n+ôo¢Õâ@$!]Ì&À1	»>Òä³Ì^Éä_Öıuù­ÚIåŞÉà±›åÑ<¿§‡”~›Ã×÷¨×²p‰Òä§ïaÅ`¶Ãûiã?¡ªİ j›‹0w.yÜ$B!„ˆCÿïë~£„ÃXRÈÊ
hš·¤lı—º«à¿ÿ÷ÿßflÚgu'îö»{Á¾k5Uôò.m]v.µèØ§ü)ÿÇö®êî5Ş9y´™U>=Y@"“t4ê1Ê9…¥¹7[PdÓÇ‡×ü?„EAi
Yk¯•Æ4¬ÿy™¼ŞùbÇ»:C{É…B¨ä	öªî¦ÏÛä;ÔO’øÏ®İıW'-è  `Æğ#”MÍÜ¹¿ŒiUV( İ]?ÍXT!A' d¸Á¨‰;¨‰Î1˜+a8÷®ÖÃÀYNËÇ}|C$Ü3Ø7;!SRdOS¹h¬`&³4¯oñT0ü‡ÿñL€=À 'TíëG€ØT$„Ã‘ĞX$$““É£“G“Eš?“G'ƒàà9Ù™’\J„BUİ_o.T6@);j~vwÇõEJ)`y_‘¸1øˆ6|SŸ+i>g£ew‘!{ÊÜ)!+²dÆY£ês¢Óöù~‘ó{WÛƒ?*[ÿ,“·h–Ğæ…X§¥h4XãRü\ı•sC3Ëò	Hnàşm ˜¶üú£şı˜{·”æ¾oî‰ı;zß¸î»q²>j•İß_õùÇ#Ö¤{%g™÷ÔĞóÑ¹VC¦Gí¯µœm{|aôğıã¶Zì~+¨u_V×a}Çíyçé^(·¾­[Ñkpz	¨u'ªÔ;Ì®Æââ‡M¼MéRbÆaóÀr°ôìË-Ò©\ÊË ´x«û±W
Ü"J*Ò(EJÈ!·ÚÅ—èªF"‰‰©F0W<këîbáÓ%×LYQH×­!…$3¨*¾)EÜÑíT¥²æè×Êòíù‹™>ù_ı*…7v8qõ6ı[ìÑv©«E53!gCGÆu»Ã†¨4@ÀïÒ}ëFDv\ˆyßy÷·g×â¨ ı’;s:ãôúÏñ«Şj!ZhïF Wâ6İ¢l··Og`´0ü‡ÿñL€@@ 'TíçA±ĞltAA V'‚‚` z0òC>!Áûš6x= ‘ıvt–NHQG¥Çär@F´€CŒëä‡%¦‹eNâ™oƒ:Gªí#‘˜ü,rà"× `·ÁSv#†]êàÄÆo4şB>á·GîÓ©(ˆÙØ=“Ek‰¡Ê öÒR§cò"y^İ-l_áò…İ]•Å­ëŞõŸ~ÛEø[>XE´8~zäü+oÕ»3æşá³š çñNºa®;¹ZÎÄDÙÖ–w¾/ê9ÓöÔ]Ï¹©ÇP’„¥æıòrDØµ ˆ ß‘&#Ödº’B gT“m¿‰‚~“şı'pÌÁÕ¢fQ©z-¤	=}û•‰Û…¼~m¦~âª^‘Ô«V$Í¥@A(•¸C¹Å\qj9±óÕ’ ­¨›„"p@AÕô•¶kì êõD?ÍQ?Ÿd“}$;(¶
–c@åsÊ4h5´cÀ‚$•4BÌ ,¸^ü×o¢¦Ö¢2Ù Ğ±@ ÀGIcb„úßÁ×ıİ¬áRmšÑÕDTÎôùn*:–"•úÅ»$ãqÖ|KU1n0NÒˆHD>«ı_Ã×%ÿ´ò\ä,Cæªšj/`æ  Ï–K¨tˆÍ—ï–İîj$ÑbÃòÿñL€  'U¨A!@P$	("
ô£ „:–4m÷,óO²½%?C…@ã^-Â*h¦ß×ğıït„0ü‡ÿñL€:@ 'TõÍA´Ğ¬48ÅB° HHƒ!°ÈX$$	Ñ‡±fy,ÂÏÜö(ô} $¹ÉÇÎå%AäpùêZàË™ÔD d0"d?Üò¾ñ¿@“ƒ½í%û–ñÜ³åZë/İ õµ:…ºH`ò*‘W‘ñ® ŸŞtüñæzê­ÿõòãí>c¶ûˆ×“ìü{~ÌPı¯­?s¡s¬´¤–¾md€“’í?Uò¯ş¾‹6¨é={üıÅ§ƒc)ää™¨Ÿíü?½x±‚’Xi/ß?ú®aü©°Pvy˜˜ô›«sİ¤ìÿ&·EåØ?±S¢Uc@¢U3ì;÷¶7|¾vgweÉO2Õz»Vt(Œ €‹